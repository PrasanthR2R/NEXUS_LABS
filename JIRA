/*******************************
 * NEXUS ‚Äî JIRA TRACKER (Final + Teams, robust Sheets access)
 * - Pulls Jira issues (incl. description) to "Tickets"
 * - Logs run status to health log
 * - Sends Teams alerts (new, closed, daily summary)
 * - Uses explicit workbook ID + locking + retries to avoid timeouts
 *******************************/

/*** CONFIG ***/
// Jira
const JIRA_SITE   = 'latcha.atlassian.net';
const DEFAULT_JQL = 'statusCategory != Done ORDER BY updated DESC';

// Workbook (explicit ID to avoid getActive() timeouts)
const WORKBOOK_ID = '14ScwQOZ1jnbcsTJZ85_HWPVuOKNXMytc0Yuc2M9M1VQ';
const TICKETS_TAB = 'Tickets';

// Health log sheet
const HEALTH_SHEET_ID = '18NPm8ZUkskHxTPqRrDrNTwlujlWDInJcHEVuPeJqSUg';
const HEALTH_TAB_NAME = 'NEXUS_Engine_Health_Log';

// Fields to fetch from Jira
const FIELDS = [
  'project','summary','description','issuetype','status','statuscategorychangedate','assignee',
  'priority','labels','components','fixVersions','versions',
  'duedate','created','updated','reporter','resolution','resolutiondate','parent'
];

// Teams (Incoming Webhook) ‚Äî EXACT URL
const TEAMS_WEBHOOK_URL = 'https://clictechnologies.webhook.office.com/webhookb2/d1d4f6f7-5378-4d2d-ba87-aedba03b3585@a4e69a77-1b2a-432a-b01b-19ce339290cc/IncomingWebhook/ce2aaaaa97d242049dad68d2e1510e4b/67cddb26-ab0c-4458-9ab3-9d33d615642b/V2SEg2b5gi7D5niMDk_-AB8vzLf_1E22jedqOwplyUFKU1';

const SNAPSHOT_SHEET = '_Snapshot'; // internal diff sheet

// Fixed header (24 cols)
const TICKETS_HEADER = [
  'issueKey','projectKey','projectName','summary','description','issueType','status',
  'assignee','assigneeEmail','priority','labels','components','fixVersions','versions',
  'dueDate','created','updated','reporter','reporterEmail','resolution','resolutionDate',
  'statusCategoryChanged','parentKey','url'
];
const TICKETS_COLS = TICKETS_HEADER.length;

/*** ONE-TIME: store Jira secrets, then remove literals ***/
function setSecrets() {
  const JIRA_EMAIL = 'YOUR_JIRA_EMAIL@company.com';
  const JIRA_API_TOKEN = 'YOUR_API_TOKEN_HERE';
  if (!JIRA_EMAIL || !JIRA_API_TOKEN) throw new Error('Provide JIRA_EMAIL and JIRA_API_TOKEN.');
  PropertiesService.getScriptProperties().setProperties({ JIRA_EMAIL, JIRA_API_TOKEN }, true);
  Logger.log('Secrets saved.');
}

/*** MAIN: pull issues + write logs ***/
function Sync_Jira_Issues() {
  const t0 = new Date();
  const ENGINE = 'Jira Tracker Engine';
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000); // prevent overlap
    const { headers, base } = getCreds_();
    const issues = fetchIssuesByJQL_(base, headers, DEFAULT_JQL);
    writeToSheet_(issues);
    logHealth_(ENGINE, t0, 'OK', '');
  } catch (e) {
    logHealth_(ENGINE, t0, 'ERROR', e && e.message ? e.message : String(e));
    throw e;
  } finally {
    try { lock.releaseLock(); } catch(_) {}
  }
}

/*** Hourly entrypoint = sync + Teams notifications ***/
function Run_Hourly_Sync_And_Notifications() {
  const t0 = new Date();
  const ENGINE = 'Jira Hourly Sync + Teams Notify';
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000);
    Sync_Jira_Issues();   // refresh the sheet first
    detectAndNotify_();   // compare with snapshot + post Teams alerts
    logHealth_(ENGINE, t0, 'OK', '');
  } catch (e) {
    logHealth_(ENGINE, t0, 'ERROR', e && e.message ? e.message : String(e));
    throw e;
  } finally {
    try { lock.releaseLock(); } catch(_) {}
  }
}

/*** Daily summary sender (create a daily trigger for this) ‚Äî ALWAYS POSTS ***/
function Send_Daily_Summary_To_Teams() {
  const t0 = new Date();
  const ENGINE = 'Jira Daily Summary';
  try {
    const summary = buildDailySummary_();  // { totalCreated, totalClosed, openCount, extraText }
    Logger.log('[Daily Summary Computed] ' + JSON.stringify(summary));

    // Always send a card, even if all counts are zero
    const ok = postTeamsCard_({
      title: 'üìä Daily Jira Summary',
      summary: 'Daily Jira Summary',
      themeColor: '0078D4',
      activityTitle: `**Daily Summary (${formatDate_(new Date(), 'yyyy-MM-dd')})**`,
      facts: [
        { name: 'New tickets', value: String(summary.totalCreated) },
        { name: 'Closed tickets', value: String(summary.totalClosed) },
        { name: 'Open tickets (now)', value: String(summary.openCount) }
      ],
      text: summary.extraText || '_No extra notes for today._',
      button: { name: 'Open Tickets Sheet', uri: getWorkbook_().getUrl() }
    });

    if (!ok) throw new Error('Teams webhook did not accept Daily Summary (see health log for details).');

    logHealth_(ENGINE, t0, 'OK', '');
  } catch (e) {
    logHealth_(ENGINE, t0, 'ERROR', e && e.message ? e.message : String(e));
    throw e;
  }
}

/*** Core helpers ***/
function getCreds_() {
  const props = PropertiesService.getScriptProperties();
  const email = props.getProperty('JIRA_EMAIL');
  const token = props.getProperty('JIRA_API_TOKEN');
  if (!email || !token) throw new Error('Missing secrets. Run setSecrets() with your Jira email + API token.');
  const auth = Utilities.base64Encode(email + ':' + token);
  return {
    headers: {
      Authorization: 'Basic ' + auth,
      Accept: 'application/json',
      'Content-Type': 'application/json'
    },
    base: `https://${JIRA_SITE}/rest/api/3`
  };
}

/** Robust Jira search with pagination & retries */
function fetchIssuesByJQL_(base, headers, jql) {
  const out = [];
  let startAt = 0;
  const pageSize = 100;

  while (true) {
    const qs = [
      `jql=${encodeURIComponent(jql)}`,
      `startAt=${startAt}`,
      `maxResults=${pageSize}`,
      `fields=${encodeURIComponent(FIELDS.join(','))}`
    ].join('&');

    const url = `${base}/search?${qs}`;
    const res = fetchWithRetry_(url, { method: 'get', headers, muteHttpExceptions: true });

    if (res.getResponseCode() !== 200) {
      const body = safeJson_(res.getContentText()) || {};
      const details = [
        ...(body.errorMessages || []),
        ...Object.values(body.errors || {})
      ].join(' | ');
      throw new Error(`Jira search failed ${res.getResponseCode()}: ${details || res.getContentText()}`);
    }

    const body = JSON.parse(res.getContentText());
    const issues = body.issues || [];
    out.push(...issues);

    const total   = typeof body.total === 'number' ? body.total : null;
    const current = typeof body.startAt === 'number' ? body.startAt : startAt;
    startAt = current + issues.length;

    if (total !== null && startAt >= total) break;
    if (issues.length === 0) break;
  }
  return out;
}

/** UrlFetch with exponential backoff and 429 support */
function fetchWithRetry_(url, opts, maxAttempts = 5) {
  let attempt = 0;
  let waitMs = 500;
  while (true) {
    attempt++;
    const res = UrlFetchApp.fetch(url, { followRedirects: true, validateHttpsCertificates: true, ...opts });
    const code = res.getResponseCode();
    if ((code >= 200 && code < 300) || (code >= 400 && code < 500 && code !== 429)) return res;
    if (attempt >= maxAttempts) return res;

    let retryAfter = 0;
    try { retryAfter = Number((res.getAllHeaders() || {})['Retry-After']) * 1000 || 0; } catch (_) {}
    Utilities.sleep(retryAfter || waitMs);
    waitMs = Math.min(waitMs * 2, 8000);
  }
}

/** Workbook + Sheet helpers with retries */
function getWorkbook_() {
  return withRetry_(() => SpreadsheetApp.openById(WORKBOOK_ID));
}
function getSheet_(name) {
  return withRetry_(() => {
    const ss = getWorkbook_();
    let sh = ss.getSheetByName(name);
    if (!sh) sh = ss.insertSheet(name);
    return sh;
  });
}
function withRetry_(fn, max = 5, initialWait = 400) {
  let attempt = 0, wait = initialWait;
  while (true) {
    attempt++;
    try {
      return fn();
    } catch (e) {
      if (attempt >= max) throw e;
      Utilities.sleep(wait);
      wait = Math.min(wait * 2, 6000);
    }
  }
}

/** Write issues to "Tickets" (recreates header, freezes row 1, formats dates) */
function writeToSheet_(issues) {
  const sh = getSheet_(TICKETS_TAB);

  sh.clearContents();
  sh.getRange(1, 1, 1, TICKETS_COLS).setValues([TICKETS_HEADER]);
  sh.setFrozenRows(1);

  const rows = issues.map(({ key, fields }) => {
    const projKey  = safe(fields, ['project','key']);
    const projName = safe(fields, ['project','name']);
    const assignee = safe(fields, ['assignee','displayName']) || '';
    const assEmail = safe(fields, ['assignee','emailAddress']) || '';
    const reporter = safe(fields, ['reporter','displayName']) || '';
    const repEmail = safe(fields, ['reporter','emailAddress']) || '';
    const listNames = arr => Array.isArray(arr) ? arr.map(x => x && (x.name || x.key) || '').filter(Boolean).join(', ') : '';
    const descriptionPlain = adfToText_(fields.description);

    return [
      key,
      projKey || '',
      projName || '',
      fields.summary || '',
      descriptionPlain || '',
      safe(fields, ['issuetype','name']) || '',
      safe(fields, ['status','name']) || '',
      assignee,
      assEmail,
      safe(fields, ['priority','name']) || '',
      Array.isArray(fields.labels) ? fields.labels.join(', ') : '',
      listNames(fields.components),
      listNames(fields.fixVersions),
      listNames(fields.versions),
      fields.duedate || '',
      fields.created || '',
      fields.updated || '',
      reporter,
      repEmail,
      safe(fields, ['resolution','name']) || '',
      fields.resolutiondate || '',
      fields.statuscategorychangedate || '',
      safe(fields, ['parent','key']) || '',
      `https://${JIRA_SITE}/browse/${key}`
    ];
  });

  if (rows.length) {
    sh.getRange(2, 1, rows.length, TICKETS_COLS).setValues(rows);
  }

  const dateCols = [15,16,17,22,23]; // due, created, updated, resolutionDate, statusCategoryChanged
  dateCols.forEach(c => {
    const n = Math.max(rows.length, 1);
    sh.getRange(2, c, n, 1).setNumberFormat('yyyy-mm-dd hh:mm');
  });

  sh.autoResizeColumns(1, TICKETS_COLS);
}

/*** Health log ***/
function logHealth_(engineName, t0, status, errorMsg) {
  const runtime = ((new Date()) - t0) / 1000;
  const ss = SpreadsheetApp.openById(HEALTH_SHEET_ID);
  const sh = ss.getSheetByName(HEALTH_TAB_NAME) || ss.insertSheet(HEALTH_TAB_NAME);
  if (sh.getLastRow() === 0) {
    sh.appendRow(['Engine Name','Timestamp','Status','Runtime','Error']);
  }
  const normalizedStatus = String(status).toUpperCase() === 'SUCCESS' ? 'OK'
                         : String(status).toUpperCase() === 'OK' ? 'OK'
                         : String(status).toUpperCase() === 'ERROR' ? 'ERROR'
                         : status;
  const ts = new Date();
  sh.appendRow([engineName, ts, normalizedStatus, runtime, errorMsg || '']);
  sh.getRange(sh.getLastRow(), 2).setNumberFormat('yyyy-mm-dd hh:mm:ss');
}

/*** tiny utils ***/
function safe(obj, pathArr) {
  return pathArr.reduce((acc, k) => (acc && k in acc ? acc[k] : undefined), obj);
}
function safeJson_(txt) { try { return JSON.parse(txt); } catch(_) { return null; } }

/** Convert Jira Cloud ADF (rich text) description to plain text. */
function adfToText_(adf) {
  if (!adf) return '';
  try {
    const parts = [];
    const walk = (node) => {
      if (!node) return;
      const type = node.type;

      if (type === 'text') { parts.push(node.text || ''); return; }
      if (type === 'hardBreak') { parts.push('\n'); return; }

      if (type === 'paragraph' || type === 'heading') {
        if (Array.isArray(node.content)) node.content.forEach(walk);
        parts.push('\n'); return;
      }

      if (type === 'bulletList' || type === 'orderedList') {
        const isOrdered = type === 'orderedList';
        let idx = (node.attrs && node.attrs.order) ? Number(node.attrs.order) : 1;
        (node.content || []).forEach(li => {
          const before = parts.length;
          (li.content || []).forEach(walk);
          let line = parts.splice(before).join('').trim();
          if (line) { parts.push((isOrdered ? `${idx}. ` : `‚Ä¢ `) + line + '\n'); idx++; }
        });
        return;
      }

      if (type === 'blockquote') {
        const before = parts.length;
        (node.content || []).forEach(walk);
        let text = parts.splice(before).join('');
        text = text.split('\n').map(s => s ? `> ${s}` : s).join('\n');
        parts.push(text + '\n'); return;
      }

      if (type === 'codeBlock') {
        const before = parts.length;
        (node.content || []).forEach(walk);
        const codeText = parts.splice(before).join('');
        parts.push(codeText + '\n'); return;
      }

      if (type === 'table') {
        (node.content || []).forEach(row => {
          const cells = [];
          (row.content || []).forEach(cell => {
            const before = parts.length;
            (cell.content || []).forEach(walk);
            const cellText = parts.splice(before).join('').replace(/\n+/g, ' ').trim();
            cells.push(cellText);
          });
          parts.push(cells.join(' | ') + '\n');
        });
        return;
      }

      if (Array.isArray(node.content)) node.content.forEach(walk);
    };

    if (adf.type === 'doc' && Array.isArray(adf.content)) adf.content.forEach(walk);
    else walk(adf);
    return parts.join('').replace(/\n{3,}/g, '\n\n').trim();
  } catch (e) {
    return typeof adf === 'string' ? adf : JSON.stringify(adf);
  }
}

/* ------------------------------------------------------------------
   TEAMS INTEGRATION (hourly new/closed alerts + daily summary)
-------------------------------------------------------------------*/

// Quick trigger helpers
function createHourlyTrigger_() {
  deleteTriggersByFunc_('Run_Hourly_Sync_And_Notifications');
  ScriptApp.newTrigger('Run_Hourly_Sync_And_Notifications').timeBased().everyHours(1).create();
  Logger.log('Created hourly trigger for Run_Hourly_Sync_And_Notifications');
}
function createDailySummaryTrigger_() {
  deleteTriggersByFunc_('Send_Daily_Summary_To_Teams');
  ScriptApp.newTrigger('Send_Daily_Summary_To_Teams').timeBased().atHour(18).everyDays(1).create(); // 18:00 local
  Logger.log('Created daily summary trigger for 18:00 local time');
}
function deleteTriggersByFunc_(funcName) {
  ScriptApp.getProjectTriggers().forEach(tr => {
    if (tr.getHandlerFunction() === funcName) ScriptApp.deleteTrigger(tr);
  });
}

// Optional: initialize snapshot immediately
function Initialize_Jira_Snapshot() {
  const current = loadCurrentTickets_(); // may be empty on first run
  saveSnapshot_(current);
  Logger.log('Snapshot initialized with ' + Object.keys(current).length + ' items.');
}

// Detect changes vs last snapshot and notify Teams
function detectAndNotify_() {
  const current = loadCurrentTickets_(); // map by issueKey
  const snap    = loadSnapshot_();       // map by issueKey

  const newIssues = [];
  const closedIssues = [];

  Object.keys(current).forEach(key => {
    const cur = current[key];
    const prev = snap[key];

    if (!prev) {
      newIssues.push(cur);
    } else {
      const wasDone = toBoolDone_(prev.status);
      const isDone  = toBoolDone_(cur.status);
      const wasResolved = !!prev.resolutionDate;
      const isResolved  = !!cur.resolutionDate;
      if ((!wasDone && isDone) || (!wasResolved && isResolved)) {
        closedIssues.push(cur);
      }
    }
  });

  newIssues.forEach(issue => notifyNewIssue_(issue));
  closedIssues.forEach(issue => notifyClosedIssue_(issue));

  saveSnapshot_(current);
}

// Sheet helpers for diffing
function loadCurrentTickets_() {
  const sh = getSheet_(TICKETS_TAB);
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return {};
  const values = sh.getRange(2, 1, lastRow - 1, TICKETS_COLS).getValues();

  const H = {
    issueKey:1, projectKey:2, summary:4, issueType:6, status:7,
    assignee:8, priority:10, dueDate:15, created:16, updated:17, resolution:20, resolutionDate:21, url:24
  };
  const map = {};
  values.forEach(r => {
    const key = String(r[H.issueKey-1] || '').trim();
    if (!key) return;
    map[key] = {
      issueKey: key,
      projectKey: String(r[H.projectKey-1]||'').trim(),
      summary: String(r[H.summary-1]||''),
      issueType: String(r[H.issueType-1]||''),
      status: String(r[H.status-1]||''),
      assignee: String(r[H.assignee-1]||''),
      priority: String(r[H.priority-1]||''),
      dueDate: toIsoDateOnly_(r[H.dueDate-1]),
      created: toIso_(r[H.created-1]),
      updated: toIso_(r[H.updated-1]),
      resolution: String(r[H.resolution-1]||''),
      resolutionDate: toIso_(r[H.resolutionDate-1]),
      url: String(r[H.url-1]||'')
    };
  });
  return map;
}

function loadSnapshot_() {
  const sh = getSheet_(SNAPSHOT_SHEET);
  const last = sh.getLastRow();
  if (last < 2) return {};
  const values = sh.getRange(2, 1, last - 1, 8).getValues();
  const map = {};
  values.forEach(r => {
    const key = String(r[0]||'').trim();
    if (!key) return;
    map[key] = {
      status: String(r[1]||''),
      resolution: String(r[2]||''),
      resolutionDate: String(r[3]||''),
      updated: String(r[4]||''),
      priority: String(r[5]||''),
      assignee: String(r[6]||''),
      dueDate: String(r[7]||'')
    };
  });
  return map;
}

function saveSnapshot_(currentMap) {
  const sh = getSheet_(SNAPSHOT_SHEET);
  sh.clearContents();
  sh.getRange(1, 1, 1, 8).setValues([['issueKey','status','resolution','resolutionDate','updated','priority','assignee','dueDate']]);
  const rows = Object.keys(currentMap).map(k => {
    const it = currentMap[k];
    return [k, it.status, it.resolution, it.resolutionDate || '', it.updated || '', it.priority || '', it.assignee || '', it.dueDate || '' ];
  });
  if (rows.length) sh.getRange(2, 1, rows.length, 8).setValues(rows);
  // sh.hideSheet(); // optional
}

// Status helper
function toBoolDone_(status) {
  if (!status) return false;
  const s = status.toLowerCase();
  return ['done','closed','resolved','complete'].some(k => s.includes(k));
}

// Teams notifications
function notifyNewIssue_(it) {
  const priorityEmoji = priorityIcon_(it.priority);
  const headline = (it.projectKey === 'MAX')
    ? 'üÜï Hey team, a new Jira ticket has been created for Project MAX ‚Äî take a look. üöÄ'
    : 'üÜï New Jira ticket created ‚Äî take a look.';

  postTeamsCard_({
    title: headline,
    summary: 'New Jira ticket',
    themeColor: 'F39C12',
    activityTitle: `**${escapeMd_(it.summary)}**`,
    facts: [
      { name: 'Key', value: it.issueKey },
      { name: 'Project', value: it.projectKey || '-' },
      { name: 'Type', value: it.issueType || '-' },
      { name: 'Priority', value: (it.priority || '-') + (priorityEmoji ? ' ' + priorityEmoji : '') },
      { name: 'Assignee', value: it.assignee || '-' },
      { name: 'Created', value: it.created || '-' }
    ],
    text: '',
    button: { name: 'Open in Jira', uri: it.url }
  });
}

function notifyClosedIssue_(it) {
  postTeamsCard_({
    title: '‚úÖ Ticket closed',
    summary: 'Jira ticket closed',
    themeColor: '6B6B6B',
    activityTitle: `**${escapeMd_(it.summary)}**`,
    facts: [
      { name: 'Key', value: it.issueKey },
      { name: 'Project', value: it.projectKey || '-' },
      { name: 'Status', value: it.status || 'Done' },
      { name: 'Resolution', value: it.resolution || '-' },
      { name: 'Closed on', value: it.resolutionDate || '-' }
    ],
    text: '',
    button: { name: 'Open in Jira', uri: it.url }
  });
}

/** Robust Teams post: retries + logs + body check. Returns true on success ("1"). */
function postTeamsCard_({ title, summary, themeColor, activityTitle, facts = [], text = '', button }) {
  if (!TEAMS_WEBHOOK_URL) {
    logHealth_('Teams Notify', new Date(), 'ERROR', 'Missing TEAMS_WEBHOOK_URL');
    return false;
  }

  const payload = {
    '@type': 'MessageCard',
    '@context': 'http://schema.org/extensions', // per Microsoft examples
    summary: summary || title,
    themeColor: themeColor || '0078D4',
    title,
    sections: [{
      activityTitle: activityTitle || title,
      facts: facts,
      markdown: true,
      text: text || ''
    }],
    potentialAction: button ? [{
      '@type': 'OpenUri',
      name: button.name || 'Open',
      targets: [{ os: 'default', uri: button.uri }]
    }] : []
  };

  const body = JSON.stringify(payload);

  let attempt = 0, wait = 500;
  while (true) {
    attempt++;
    try {
      const res = UrlFetchApp.fetch(TEAMS_WEBHOOK_URL, {
        method: 'post',
        contentType: 'application/json; charset=utf-8',
        payload: body,
        muteHttpExceptions: true,
        followRedirects: true,
        validateHttpsCertificates: true
      });
      const code = res.getResponseCode();
      const txt = (res.getContentText() || '').trim();

      // Success criteria: HTTP 2xx AND body empty or "1"
      const success = (code >= 200 && code < 300) && (txt === '' || txt === '1');

      // Teams sometimes embeds errors in body as 200 responses; detect common pattern
      const bodyHasError = /Microsoft Teams endpoint returned HTTP error|Bad payload/i.test(txt);

      if (success && !bodyHasError) return true;

      const msg = `Teams webhook response ${code}: ${txt || '(no body)'}`;
      if (attempt >= 5) { logHealth_('Teams Notify', new Date(), 'ERROR', msg); return false; }
      Utilities.sleep(wait); wait = Math.min(wait * 2, 8000);
    } catch (err) {
      if (attempt >= 5) {
        logHealth_('Teams Notify', new Date(), 'ERROR', `Fetch error: ${String(err)}`);
        return false;
      }
      Utilities.sleep(wait); wait = Math.min(wait * 2, 8000);
    }
  }
}

/** Minimal text ping to verify the webhook path. Logs code + body. */
function Send_Teams_Text_Ping() {
  if (!TEAMS_WEBHOOK_URL) throw new Error('Missing TEAMS_WEBHOOK_URL');
  const payload = { text: 'Ping from Apps Script ' + new Date().toISOString() };
  const res = UrlFetchApp.fetch(TEAMS_WEBHOOK_URL, {
    method: 'post',
    contentType: 'application/json; charset=utf-8',
    payload: JSON.stringify(payload),
    muteHttpExceptions: true,
    followRedirects: true,
    validateHttpsCertificates: true
  });
  Logger.log(`Ping -> code=${res.getResponseCode()} body="${res.getContentText()}"`);
}

/** Quick end-to-end webhook validation: text ping + message card. */
function Validate_Teams_Webhook_() {
  Send_Teams_Text_Ping();
  Send_Teams_Test_Card();
}

// Daily summary builder
function buildDailySummary_() {
  const sh = getSheet_(TICKETS_TAB);
  const last = sh.getLastRow();
  if (last < 2) return { totalCreated:0,totalClosed:0,openCount:0,extraText:'' };
  const values = sh.getRange(2, 1, last - 1, TICKETS_COLS).getValues();

  const H = { created:16, resolutionDate:21, status:7, priority:10, dueDate:15, issueKey:1, summary:4, url:24 };
  const today = formatDate_(new Date(), 'yyyy-MM-dd');

  let totalCreated = 0, totalClosed = 0, openCount = 0;
  const byPriority = {};
  const dueToday = [];

  values.forEach(r => {
    const status = String(r[H.status-1]||'');
    const created = toIso_(r[H.created-1]);
    const resolutionDate = toIso_(r[H.resolutionDate-1]);
    const priority = String(r[H.priority-1]||'').trim();
    const dueDate = toIsoDateOnly_(r[H.dueDate-1]);
    const issueKey = String(r[H.issueKey-1]||'');
    const summary = String(r[H.summary-1]||'');
    const url = String(r[H.url-1]||'');

    if (created && created.startsWith(today)) totalCreated++;
    if (resolutionDate && resolutionDate.startsWith(today)) totalClosed++;
    if (!toBoolDone_(status)) openCount++;

    if (priority) byPriority[priority] = (byPriority[priority] || 0) + 1;
    if (dueDate && dueDate === today && !toBoolDone_(status)) {
      dueToday.push(`- ${issueKey}: ${summary}`);
    }
  });

  const priorityLines = Object.keys(byPriority).sort().map(k => `- ${k}: ${byPriority[k]}`);
  const extra = [
    priorityLines.length ? `**Open by priority:**\n${priorityLines.join('\n')}` : '',
    dueToday.length ? `\n**Due today (open):**\n${dueToday.join('\n')}` : ''
  ].filter(Boolean).join('\n');

  return { totalCreated, totalClosed, openCount, extraText: extra };
}

// Small utils
function toIso_(v) {
  if (!v) return '';
  try {
    if (v instanceof Date) return Utilities.formatDate(v, Session.getScriptTimeZone(), 'yyyy-MM-dd\'T\'HH:mm:ss');
    const s = String(v);
    const m = s.match(/^(\d{4}-\d{2}-\d{2})/);
    return m ? m[1] + 'T' + (s.split('T')[1] || '00:00:00') : s;
  } catch(_) { return String(v); }
}
function toIsoDateOnly_(v) {
  if (!v) return '';
  try {
    if (v instanceof Date) return Utilities.formatDate(v, Session.getScriptTimeZone(), 'yyyy-MM-dd');
    const s = String(v); const m = s.match(/^(\d{4}-\d{2}-\d{2})/);
    return m ? m[1] : s;
  } catch(_) { return String(v); }
}
function formatDate_(d, fmt) {
  return Utilities.formatDate(d, Session.getScriptTimeZone(), fmt);
}
function escapeMd_(s){ return String(s||'').replace(/(\*|_|\`|\[|\])/g,'\\$1'); }
function priorityIcon_(p) {
  const s = String(p||'').toLowerCase();
  if (!s) return '';
  if (s.includes('critical') || s.includes('blocker') || s.includes('p0')) return 'üö®';
  if (s.includes('high') || s.includes('p1') || s.includes('urgent')) return 'üî•';
  if (s.includes('medium') || s.includes('p2')) return '‚ö†Ô∏è';
  if (s.includes('low') || s.includes('p3') || s.includes('p4')) return 'üê¢';
  return '';
}

/* ---------------------------
   DEBUG / DIAGNOSTIC HELPERS
----------------------------*/
function Send_Teams_Test_Card() {
  const ok = postTeamsCard_({
    title: '‚úÖ Teams Webhook Test',
    summary: 'Test',
    themeColor: '2EB886',
    activityTitle: '**Test card from Apps Script**',
    facts: [{ name: 'When', value: new Date().toString() }],
    text: 'If you see this, the webhook is healthy.',
    button: { name: 'Open Tickets Sheet', uri: getWorkbook_().getUrl() }
  });
  if (!ok) Logger.log('Test card failed to post. Check health log for Teams Notify errors.');
}

function Debug_Daily_Summary() {
  const s = buildDailySummary_();
  Logger.log(JSON.stringify(s, null, 2));
}
