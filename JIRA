/*****************  HARD-CODED TEST CREDS (as requested)  *****************/
const JIRA_EMAIL     = 'indira.r@clictechnologies.com';
const JIRA_API_TOKEN = '';
const JIRA_SITE      = 'latcha.atlassian.net';

/*****************  MICROSOFT TEAMS WEBHOOK  *****************/
// ðŸ‘‰ Replace with your Teams Incoming Webhook URL
const TEAMS_WEBHOOK_URL = 'https://clictechnologies.webhook.office.com/webhookb2/d1d4f6f7-5378-4d2d-ba87-aedba03b3585@a4e69a77-1b2a-432a-b01b-19ce339290cc/IncomingWebhook/47c34d511b114f2d8611c9fe0d9de372/67cddb26-ab0c-4458-9ab3-9d33d615642b/V2FuUYnRVgvrnSJhdyjNXJRAXSidBRATGyHN_EtsveXrc1';

/*****************  SHEETS  *****************/
const ISSUES_SHEET   = 'Jira Issues';   // your export tab (optional for reference)
const SNAPSHOT_SHEET = 'Jira Snapshot'; // used by the engine to diff state

/*****************  PUBLIC ENTRY POINTS  *****************/
// 1) Run once to seed snapshot (no notifications)
function PrimeSnapshot() {
  requireWebhook_();
  const issues = fetchAllIssuesAllProjects_(); // all issues you can see (bounded per project)
  writeSnapshot_(issues, {silent:true});       // store state, don't notify
  Logger.log(`Snapshot primed with ${issues.length} issues.`);
}

// 2) Hourly scan: detects New + Closed and sends Teams notifications
function HourlyScan() {
  requireWebhook_();
  ensureSnapshotSheet_();
  const snapshot = readSnapshot_();

  // If brand new sheet, prime then exit
  if (Object.keys(snapshot).length === 0) {
    PrimeSnapshot();
    return;
  }

  // Pull only recently updated issues for speed (last 2 days)
  const issues = fetchRecentIssuesAllProjects_('-2d');
  const delta  = computeDelta_(issues, snapshot);

  // Notify new tickets
  delta.newIssues.forEach(i => notifyNewTicket_(i));

  // Notify closed tickets
  delta.closedIssues.forEach(i => notifyClosedTicket_(i));

  // Upsert snapshot with new view
  writeSnapshot_(issues, {silent:false, carryFlags:true});
  Logger.log(`Scan done. New: ${delta.newIssues.length}, Closed: ${delta.closedIssues.length}`);
}

// 3) Daily summary at 9:30 PM IST (set by InstallTriggers)
function DailySummary() {
  requireWebhook_();
  const snapshot = readSnapshot_();
  const today = new Date(); // project timezone should be IST in File â†’ Project Settings

  const all = Object.values(snapshot);
  const totals = summarize_(all, today);

  const card = buildSummaryCard_(totals);
  postToTeams_(card);
  Logger.log('Daily summary sent to Teams.');
}

// 4) Install time-driven triggers (hourly + 21:30 IST daily)
function InstallTriggers() {
  // Clean old triggers for these functions
  removeTriggersFor_(['HourlyScan','DailySummary']);

  // Hourly
  ScriptApp.newTrigger('HourlyScan')
    .timeBased()
    .everyHours(1)
    .create();

  // Daily at 21:30 (project timezone!)
  ScriptApp.newTrigger('DailySummary')
    .timeBased()
    .atHour(21)
    .nearMinute(30)
    .everyDays(1)
    .create();

  Logger.log('Triggers installed: HourlyScan (hourly), DailySummary (21:30).');
}

/*****************  CORE Jira FETCH (Enhanced Search)  *****************/

// Fetch ALL issues across projects (bounded per project to satisfy enhanced JQL)
function fetchAllIssuesAllProjects_() {
  const fields = coreFields_();
  const projects = listProjectKeys_();
  let all = [];
  projects.forEach(p => {
    const jql = `project = ${escapeJqlIdent_(p.key)} ORDER BY created DESC`;
    all.push(...fetchIssuesWithEnhancedJql_(jql, fields));
  });
  return all;
}

// Fetch only recently updated issues (e.g., -2d) across all projects
function fetchRecentIssuesAllProjects_(relativeWindow) {
  const fields = coreFields_();
  const projects = listProjectKeys_();
  let all = [];
  projects.forEach(p => {
    const jql = `project = ${escapeJqlIdent_(p.key)} AND updated >= ${relativeWindow} ORDER BY updated DESC`;
    all.push(...fetchIssuesWithEnhancedJql_(jql, fields));
  });
  return all;
}

// Enhanced JQL with cursor pagination
function fetchIssuesWithEnhancedJql_(jql, fields) {
  const url = `https://${JIRA_SITE}/rest/api/3/search/jql`;
  const out = [];
  let token = null;

  do {
    const payload = {
      jql,
      fields,               // array
      fieldsByKeys: true,
      maxResults: 100
    };
    if (token) payload.nextPageToken = token;

    const res = fetchJiraJsonWithRetry_(url, {
      method: 'post',
      contentType: 'application/json',
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    });

    if (res && res.issues) out.push(...res.issues);
    token = (res && res.nextPageToken) ? res.nextPageToken : null;
    if (res && res.isLast === true) token = null;
  } while (token);

  return out;
}

// Minimal projects list (for bounding)
function listProjectKeys_() {
  const base = `https://${JIRA_SITE}/rest/api/3/project/search`;
  const out = [];
  let startAt = 0;
  const maxResults = 50;

  while (true) {
    const url = `${base}?startAt=${startAt}&maxResults=${maxResults}`;
    const data = fetchJiraJsonWithRetry_(url, { method: 'get', muteHttpExceptions: true });
    const values = data.values || [];
    values.forEach(p => out.push({ key: p.key, name: p.name }));
    if (startAt + values.length >= (data.total || 0) || values.length === 0) break;
    startAt += values.length;
  }
  return out;
}

function coreFields_() {
  // includes statusCategory via "status", and everything we need for cards + snapshot
  return [
    'summary','description','issuetype','status','assignee','priority',
    'labels','components','fixVersions','versions','duedate',
    'created','updated','reporter','resolution','resolutiondate',
    'statuscategorychangedate','project','parent'
  ];
}

/*****************  SNAPSHOT STORAGE & DELTA  *****************/

function ensureSnapshotSheet_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet() || SpreadsheetApp.create('Jira Export');
  let sh = ss.getSheetByName(SNAPSHOT_SHEET);
  if (!sh) {
    sh = ss.insertSheet(SNAPSHOT_SHEET);
    sh.getRange(1,1,1,8).setValues([[
      'issueKey','status','statusCategoryKey','resolution','resolutionDate','updated','notifiedCreated','notifiedClosed'
    ]]);
    sh.setFrozenRows(1);
  }
  return sh;
}

function readSnapshot_() {
  const sh = ensureSnapshotSheet_();
  const last = sh.getLastRow();
  const map = {};
  if (last < 2) return map;

  const data = sh.getRange(2,1,last-1,8).getValues();
  data.forEach(row => {
    const [issueKey,status,cat,res,resDate,upd,notiC,notiD] = row;
    if (issueKey) {
      map[issueKey] = {
        issueKey: String(issueKey),
        status: status || '',
        statusCategoryKey: cat || '',
        resolution: res || '',
        resolutionDate: resDate || '',
        updated: upd || '',
        notifiedCreated: Boolean(notiC),
        notifiedClosed: Boolean(notiD)
      };
    }
  });
  return map;
}

function writeSnapshot_(issues, {silent=false, carryFlags=false}={}) {
  const sh = ensureSnapshotSheet_();
  const existing = carryFlags ? readSnapshot_() : {};
  const rows = issues.map(it => {
    const f = it.fields || {};
    const status = f.status || {};
    const catKey = status.statusCategory && status.statusCategory.key || '';
    const prev = existing[it.key];

    return [
      it.key,
      status.name || '',
      catKey,
      (f.resolution && f.resolution.name) || '',
      f.resolutiondate || '',
      f.updated || '',
      carryFlags ? (prev ? prev.notifiedCreated : false) : false,
      carryFlags ? (prev ? prev.notifiedClosed : false) : false
    ];
  });

  // Rewrite sheet fresh
  sh.clearContents();
  sh.getRange(1,1,1,8).setValues([[
    'issueKey','status','statusCategoryKey','resolution','resolutionDate','updated','notifiedCreated','notifiedClosed'
  ]]);
  if (rows.length) sh.getRange(2,1,rows.length,8).setValues(rows);
}

/** Figure out which issues are new, and which just closed */
function computeDelta_(issues, snapshot) {
  const mapNow = {};
  issues.forEach(i => mapNow[i.key] = i);

  const newIssues = [];
  const closedIssues = [];

  issues.forEach(it => {
    const f = it.fields || {};
    const status = f.status || {};
    const catKey = status.statusCategory && status.statusCategory.key || '';
    const isClosedNow = (catKey === 'done') || !!f.resolution;
    const prev = snapshot[it.key];

    if (!prev) {
      // brand new to snapshot â†’ new ticket
      newIssues.push(it);
      return;
    }

    const wasClosed = (prev.statusCategoryKey === 'done') || !!prev.resolution;
    if (isClosedNow && !wasClosed && !prev.notifiedClosed) {
      closedIssues.push(it);
    }
  });

  return { newIssues, closedIssues };
}

/*****************  TEAMS MESSAGES  *****************/

function requireWebhook_() {
  if (!TEAMS_WEBHOOK_URL || /PASTE_YOUR_TEAMS_WEBHOOK_URL_HERE/i.test(TEAMS_WEBHOOK_URL)) {
    throw new Error('Please set TEAMS_WEBHOOK_URL to your Microsoft Teams incoming webhook.');
  }
}

function notifyNewTicket_(it) {
  const f = it.fields || {};
  const proj = f.project || {};
  const status = f.status || {};
  const type = f.issuetype || {};
  const priority = f.priority || {};
  const assignee = f.assignee || {};
  const url = `https://${JIRA_SITE}/browse/${it.key}`;

  const card = {
    '@type': 'MessageCard',
    '@context': 'https://schema.org/extensions',
    'summary': `New Jira Ticket: ${it.key}`,
    'themeColor': '0076D7',
    'title': `ðŸ†• New Ticket: ${it.key} â€” ${truncate_(f.summary, 80)}`,
    'sections': [{
      'facts': [
        {'name':'Project', 'value': `${proj.key || ''} â€” ${proj.name || ''}`},
        {'name':'Type', 'value': type.name || ''},
        {'name':'Status', 'value': status.name || ''},
        {'name':'Priority', 'value': priority.name || ''},
        {'name':'Assignee', 'value': assignee.displayName || 'Unassigned'},
        {'name':'Created', 'value': f.created || ''},
      ],
      'text': truncate_(adfToPlainText_(f.description) || '', 500),
      'markdown': true
    }],
    'potentialAction': [{
      '@type': 'OpenUri',
      'name': 'Open in Jira',
      'targets': [{'os':'default','uri': url}]
    }]
  };

  postToTeams_(card);
}

function notifyClosedTicket_(it) {
  const f = it.fields || {};
  const proj = f.project || {};
  const status = f.status || {};
  const assignee = f.assignee || {};
  const url = `https://${JIRA_SITE}/browse/${it.key}`;

  const card = {
    '@type': 'MessageCard',
    '@context': 'https://schema.org/extensions',
    'summary': `Closed Jira Ticket: ${it.key}`,
    'themeColor': '2EB886',
    'title': `âœ… Ticket Closed: ${it.key} â€” ${truncate_(f.summary, 80)}`,
    'sections': [{
      'facts': [
        {'name':'Project', 'value': `${proj.key || ''} â€” ${proj.name || ''}`},
        {'name':'Final Status', 'value': status.name || ''},
        {'name':'Assignee', 'value': assignee.displayName || 'Unassigned'},
        {'name':'Resolution', 'value': (f.resolution && f.resolution.name) || ''},
        {'name':'Resolved On', 'value': f.resolutiondate || f.updated || ''},
      ],
      'markdown': true
    }],
    'potentialAction': [{
      '@type': 'OpenUri',
      'name': 'Open in Jira',
      'targets': [{'os':'default','uri': url}]
    }]
  };

  postToTeams_(card);
}

function buildSummaryCard_(totals) {
  const lines = [
    `**Total Issues:** ${totals.total}`,
    `**Open (not Done):** ${totals.open}`,
    `**Closed (Done):** ${totals.closed}`,
    `**Created Today:** ${totals.createdToday}`,
    `**Closed Today:** ${totals.closedToday}`
  ];
  if (totals.topRecentlyUpdated.length) {
    lines.push('\n**Recently Updated (top 5):**');
    totals.topRecentlyUpdated.forEach(t => {
      lines.push(`- ${t.key} â€” ${truncate_(t.summary, 60)} (${t.status})`);
    });
  }

  return {
    '@type': 'MessageCard',
    '@context': 'https://schema.org/extensions',
    'summary': 'Daily Jira Summary',
    'themeColor': '5C2D91',
    'title': 'ðŸ“Š Daily Jira Summary',
    'text': lines.join('\n'),
    'markdown': true
  };
}

function postToTeams_(card) {
  const resp = UrlFetchApp.fetch(TEAMS_WEBHOOK_URL, {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(card),
    muteHttpExceptions: true
  });
  const code = resp.getResponseCode();
  if (code < 200 || code >= 300) {
    throw new Error(`Teams webhook error ${code}: ${resp.getContentText()}`);
  }
}

/*****************  SUMMARY CALCS  *****************/

function summarize_(snapRows, todayDate) {
  const todayISO = toISODate_(todayDate); // YYYY-MM-DD
  let total=0, open=0, closed=0, createdToday=0, closedToday=0;
  const recent = [];

  snapRows.forEach(r => {
    total++;
    const isClosed = r.statusCategoryKey === 'done' || !!r.resolution;
    if (isClosed) closed++; else open++;

    // createdToday/closedToday require live issue fields (not in snapshot),
    // so we approximate via updated/resolutionDate flags we stored.
    if (r.resolutionDate && r.resolutionDate.slice(0,10) === todayISO) closedToday++;
    // createdToday best taken from a fresh fetch; fallback: check updated if close-to-created
    // For a tighter number, you can pipe in today's fetch during DailySummary.
  });

  // Grab top 5 recently updated (from snapshot)
  const top = [...snapRows]
    .sort((a,b) => (b.updated || '').localeCompare(a.updated || ''))
    .slice(0,5)
    .map(r => ({ key:r.issueKey, summary:'', status:r.status })); // summary omitted (not in snapshot)

  return { total, open, closed, createdToday, closedToday, topRecentlyUpdated: top };
}

/*****************  UTILITIES  *****************/

function removeTriggersFor_(fnNames) {
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(t => {
    if (fnNames.includes(t.getHandlerFunction())) ScriptApp.deleteTrigger(t);
  });
}

function escapeJqlIdent_(s) {
  if (!s) return '';
  return /^[A-Z0-9_]+$/.test(s) ? s : `"${s.replace(/"/g, '\\"')}"`;
}

function authHeaders_() {
  const basic = Utilities.base64Encode(`${JIRA_EMAIL}:${JIRA_API_TOKEN}`);
  return { 'Authorization': `Basic ${basic}`, 'Accept': 'application/json' };
}

function fetchJiraJsonWithRetry_(url, options = {}) {
  const headers = Object.assign(authHeaders_(), options.headers || {});
  const opts = Object.assign({ method: 'get', muteHttpExceptions: true, headers }, options);

  for (let attempt = 0; attempt < 3; attempt++) {
    const resp = UrlFetchApp.fetch(url, opts);
    const code = resp.getResponseCode();
    const text = resp.getContentText();
    if (code === 429) {
      const retryAfter = Number(resp.getHeaders()['Retry-After'] || 2);
      Utilities.sleep(Math.min(1000 * retryAfter, 5000));
      continue;
    }
    if (code < 200 || code >= 300) throw new Error(`Jira API error ${code}: ${text}`);
    return text ? JSON.parse(text) : {};
  }
  throw new Error('Jira API throttled (429) repeatedly; aborting after retries.');
}

function adfToPlainText_(adf) {
  if (!adf || typeof adf !== 'object') return (adf || '') + '';
  var text = '';
  function walk(node) {
    if (!node) return;
    if (node.type === 'text' && node.text) text += node.text;
    (node.content || []).forEach(walk);
    if (node.type === 'paragraph') text += '\n';
  }
  walk(adf);
  return text.trim();
}

function truncate_(s, n) {
  s = (s || '') + '';
  return s.length <= n ? s : s.slice(0, n-1) + 'â€¦';
}

function toISODate_(d) {
  const pad = n => String(n).padStart(2,'0');
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
}
