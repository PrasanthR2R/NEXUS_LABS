/*******************************
 * Azure DevOps → Google Sheets (Turbo Max CRM, Selector-enabled, auto-refresh)
 * Tabs: Tasks, Bugs, Resource Summary, Capacity (Per-Day), Remaining_Log
 * Entry points:
 *   - setupSprintSelector()  ← run once to create dropdown (Current + last 3)
 *   - runSprintReport_Selected()
 *   - runSprintReport_Current()
 *   - enableSprintAutoRefresh() / disableSprintAutoRefresh()
 *******************************/

// ==== HARD-CODED CONFIG (Turbo Max CRM) ====
const ADO_ORG        = "Clictell";
const ADO_PROJECT_ID = "0b0a27a1-82bc-4fee-b3fe-cccbfb1a3164"; // Turbo Max CRM (GUID)
const ADO_TEAM       = "Turbo Max CRM Team";                   // EXACT team name as in Boards → Teams
const ADO_PAT        = ""; // test PAT

// Sheets & UI
const SHEET_SELECTOR = "Sprint Selector";
const SHEET_INDEX    = "_SprintIndex"; // hidden map Name↔Id/Path/Start/End

// UI theme
const THEME_HEADER_BG = "#e8cc86";
const THEME_ROW_BAND  = SpreadsheetApp.BandingTheme.LIGHT_GREY;

/** ======================= MENU ======================= **/
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu("Sprint Report")
    .addItem("Setup Sprint Selector (Current + last 3)", "setupSprintSelector")
    .addItem("Refresh Selected Sprint", "runSprintReport_Selected")
    .addItem("Refresh Current Sprint", "runSprintReport_Current")
    .addSeparator()
    .addItem("Enable Auto-Refresh on Sprint Change", "enableSprintAutoRefresh")
    .addItem("Disable Auto-Refresh Trigger", "disableSprintAutoRefresh")
    .addToUi();
}

/** =================== ENTRY POINTS =================== **/

function runSprintReport_Current() {
  const cfg = { org: ADO_ORG, projectId: ADO_PROJECT_ID, team: ADO_TEAM, pat: ADO_PAT };
  const iteration = getCurrentIteration_(cfg);
  runSprintReport_ForIteration_(cfg, iteration);
}

function setupSprintSelector() {
  const cfg = { org: ADO_ORG, projectId: ADO_PROJECT_ID, team: ADO_TEAM, pat: ADO_PAT };

  const current = safeGetCurrentIteration_(cfg); // may be null if no current sprint
  const past3 = safeGetPastIterations_(cfg, 3);  // timeframe-safe

  // Build list = Current (if any) + last 3 past (descending by start)
  const list = [];
  if (current) list.push(current);
  list.push.apply(list, past3);
  list.sort((a,b)=> new Date(b.attributes.startDate) - new Date(a.attributes.startDate));

  // Write hidden index
  const ss = SpreadsheetApp.getActive();
  const idx = ss.getSheetByName(SHEET_INDEX) || ss.insertSheet(SHEET_INDEX);
  idx.clear();
  idx.appendRow(["Name","ID","Path","Start","End"]);
  list.forEach(it => {
    idx.appendRow([
      it.name, it.id, it.path,
      new Date(it.attributes.startDate), new Date(it.attributes.finishDate)
    ]);
  });
  idx.hideSheet();

  // Sprint Selector sheet with dropdown
  const sh = ss.getSheetByName(SHEET_SELECTOR) || ss.insertSheet(SHEET_SELECTOR);
  sh.clear();
  sh.appendRow(["Selected Sprint", "Pick a sprint name"]);
  sh.setFrozenRows(1);
  const namesRange = idx.getRange(2,1,Math.max(0, idx.getLastRow()-1),1);
  if (namesRange.getNumRows() > 0) {
    const rule = SpreadsheetApp.newDataValidation()
      .requireValueInRange(namesRange, true)
      .setAllowInvalid(false)
      .build();
    sh.getRange("B2").setDataValidation(rule);
    // Preselect the first entry (usually current)
    sh.getRange("B2").setValue(idx.getRange(2,1).getValue());
  } else {
    sh.getRange("B2").setValue("No sprints found");
  }
  sh.getRange("A1:B1").setBackground(THEME_HEADER_BG).setFontWeight("bold");
  sh.autoResizeColumns(1,2);
  applyTableStyle_(SHEET_SELECTOR);

  // Immediately render the selected sprint
  runSprintReport_Selected();
}

function runSprintReport_Selected() {
  const cfg = { org: ADO_ORG, projectId: ADO_PROJECT_ID, team: ADO_TEAM, pat: ADO_PAT };
  const ss = SpreadsheetApp.getActive();
  const sel = ss.getSheetByName(SHEET_SELECTOR);
  const idx = ss.getSheetByName(SHEET_INDEX);
  if (!sel || !idx) return;

  const name = (sel.getRange("B2").getDisplayValue() || "").trim();
  if (!name || name === "No sprints found") return;

  const rows = idx.getRange(2,1,Math.max(0, idx.getLastRow()-1),5).getValues();
  const rec = rows.find(r => String(r[0]).trim() === name);
  if (!rec) return;

  const iteration = {
    name: rec[0], id: rec[1], path: rec[2],
    attributes: { startDate: rec[3], finishDate: rec[4] }
  };
  runSprintReport_ForIteration_(cfg, iteration);
}

/** ============== AUTO-REFRESH TRIGGER ============== **/

function enableSprintAutoRefresh() {
  removeSprintAutoRefreshTriggers_(); // clear dupes
  ScriptApp.newTrigger("onSprintSelectEdit")
    .forSpreadsheet(SpreadsheetApp.getActive())
    .onEdit()
    .create();

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  if (ss && ss.toast) ss.toast("Auto-refresh enabled. Change Sprint Selector!B2 to refresh.", "Sprint Report", 5);
  Logger.log("Auto-refresh ENABLED");
}

function disableSprintAutoRefresh() {
  removeSprintAutoRefreshTriggers_();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  if (ss && ss.toast) ss.toast("Auto-refresh disabled.", "Sprint Report", 5);
  Logger.log("Auto-refresh DISABLED");
}

function removeSprintAutoRefreshTriggers_() {
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(t => {
    if (t.getHandlerFunction() === "onSprintSelectEdit") {
      ScriptApp.deleteTrigger(t);
    }
  });
}

// Trigger handler (installable onEdit). No UI prompts here (triggers can't use UI).
function onSprintSelectEdit(e) {
  try {
    if (!e) return; // safety
    const range = e.range;
    const sh = range.getSheet();
    if (sh.getName() !== SHEET_SELECTOR) return;
    // Only react to B2
    if (range.getRow() === 2 && range.getColumn() === 2) {
      runSprintReport_Selected();
    }
  } catch (err) {
    Logger.log("onSprintSelectEdit error: " + err);
  }
}

/** ============== CORE REPORT (by iteration) ============== **/
function runSprintReport_ForIteration_(cfg, iteration) {
  const sprintName = iteration.name;
  const sprintPath = iteration.path;
  const sprintStart = new Date(iteration.attributes.startDate);
  const sprintEnd   = new Date(iteration.attributes.finishDate);

  // Team days off & working dates
  const teamDayOffSet = getTeamDaysOff_(cfg, iteration.id);
  const workingDates  = enumerateWorkingDatesTeamAware_(sprintStart, sprintEnd, teamDayOffSet);

  // Capacity by user
  let capacityByUser = {};
  try {
    capacityByUser = getCapacityByUser_(cfg, iteration.id, sprintStart, sprintEnd, teamDayOffSet);
  } catch (e) {
    capacityByUser = {};
  }

  // Work items
  const ids = queryWorkItemIdsForIteration_(cfg, sprintPath, ["Task","Bug"]);
  const fields = [
    "System.Id","System.WorkItemType","System.Title","System.State","Microsoft.VSTS.Common.Priority",
    "System.AssignedTo","Microsoft.VSTS.Scheduling.Effort","Microsoft.VSTS.Scheduling.OriginalEstimate",
    "Microsoft.VSTS.Scheduling.RemainingWork","Microsoft.VSTS.Scheduling.StartDate","Microsoft.VSTS.Scheduling.DueDate",
    "Microsoft.VSTS.Common.ClosedDate","Microsoft.VSTS.Common.Activity","System.IterationPath"
  ];
  const items = fetchWorkItemsBatch_(cfg, ids, fields);

  // Transform
  const today = todayMidnight_();
  const expectedPct = expectedPercentWorkingDays_(today, workingDates);

  const rowsTasks = [];
  const rowsBugs  = [];
  const rollup = {};

  for (const wi of items) {
    const f = wi.fields || {};
    const theId = wi.id || "";
    const type = (f["System.WorkItemType"] || "").toString();
    const typeLc = type.toLowerCase();
    const title = f["System.Title"] || "";
    const state = f["System.State"] || "";
    const priority = toNumber_(f["Microsoft.VSTS.Common.Priority"]);
    const assignedTo = extractAssignee_(f["System.AssignedTo"]);
    const effort = pickNumber_(f["Microsoft.VSTS.Scheduling.Effort"], f["Microsoft.VSTS.Scheduling.OriginalEstimate"]);
    const remaining = toNumber_(f["Microsoft.VSTS.Scheduling.RemainingWork"]);
    const startDate = toDateOrNull_(f["Microsoft.VSTS.Scheduling.StartDate"]);
    const dueDate   = toDateOrNull_(f["Microsoft.VSTS.Scheduling.DueDate"]);
    const closedDate= toDateOrNull_(f["Microsoft.VSTS.Common.ClosedDate"]);
    const activity  = f["Microsoft.VSTS.Common.Activity"] || "";
    const iterationPath = f["System.IterationPath"] || "";

    const progressPct = progressPercent_(effort, remaining, state);
    const utilized    = Math.min((effort || 0), Math.max(0, (effort || 0) - (remaining || 0)));

    const status = computeStatus_({ state, progressPct, expectedPct, dueDate, startDate });

    const row = [
      theId, type, title, assignedTo, state, priority,
      effort, remaining,
      asDateValue_(startDate), asDateValue_(dueDate), asDateValue_(closedDate),
      activity, iterationPath,
      round2_(progressPct), round2_(expectedPct),
      status,
      round2_(utilized)
    ];
    if (typeLc === "bug") rowsBugs.push(row); else rowsTasks.push(row);

    if (assignedTo) {
      rollup[assignedTo] = rollup[assignedTo] || { planned: 0, actual: 0, remaining: 0 };
      rollup[assignedTo].planned   += (effort || 0);
      rollup[assignedTo].actual    += utilized;
      rollup[assignedTo].remaining += (remaining || 0);
    }
  }

  // Write Tasks / Bugs
  const headers = [
    "ID","Work Item Type","Title","Assigned To","State","Priority",
    "Effort","Remaining","Start Date","Due Date","Closed Date",
    "Activity","Iteration Path","Progress %","Expected %","Status","Utilized"
  ];
  upsertSheet_("Tasks", headers, rowsTasks);
  applyTableStyle_("Tasks"); applyStatusColorRules_("Tasks", 16);

  upsertSheet_("Bugs", headers, rowsBugs);
  applyTableStyle_("Bugs"); applyStatusColorRules_("Bugs", 16);

  // Resource Summary
  const resRows = [];
  const allPeople = new Set(Object.keys(rollup).concat(Object.keys(capacityByUser)));
  for (const person of allPeople) {
    const r = rollup[person] || { planned: 0, actual: 0, remaining: 0 };
    const capObj = capacityByUser[person] || {
      capacityPerDay: 0, workingDays: workingDates.length, daysOffCount: 0, effectiveCapacity: 0
    };
    const planned = r.planned, actual = r.actual, remaining = r.remaining, effCap = capObj.effectiveCapacity || 0;
    const progressPctPerson = planned > 0 ? (actual/planned*100) : 0;
    const allocationPct     = effCap > 0 ? (planned/effCap*100) : 0;
    const utilizationPct    = effCap > 0 ? (actual/effCap*100) : 0;

    resRows.push([
      person, sprintName,
      round2_(capObj.capacityPerDay || 0),
      capObj.workingDays || 0,
      capObj.daysOffCount || 0,
      round2_(effCap),
      round2_(planned),
      round2_(actual),
      round2_(remaining),
      round2_(progressPctPerson),
      round2_(allocationPct),
      round2_(utilizationPct)
    ]);
  }

  const resHeaders = [
    "Resource","Sprint","Capacity per Day (hrs)","Working Days","Days Off (days)","Effective Sprint Capacity (hrs)",
    "Planned Hours (Σ Effort)","Actual Hours Spent (Σ Utilized)","Remaining Hours (Σ Remaining)",
    "Progress % (Actual/Planned)","Allocation % (Planned/Capacity)","Utilization % (Actual/Capacity)"
  ];
  upsertSheet_("Resource Summary", resHeaders, sortBy_(resRows, 0));
  applyTableStyle_("Resource Summary");

  // Capacity (Per-Day)
  buildCapacityPerDayFromApi_("Capacity (Per-Day)", workingDates, capacityByUser, rollup);
  applyTableStyle_("Capacity (Per-Day)");

  // Banners
  ["Tasks","Bugs","Resource Summary","Capacity (Per-Day)"].forEach(n => stampSprintBanner_(n, sprintName, sprintStart, sprintEnd));
}

/** ============== Iteration lookup helpers (timeframe-safe) ============== **/
function safeGetCurrentIteration_(cfg) {
  try { return getCurrentIteration_(cfg); } catch(e) { return null; }
}

function safeGetPastIterations_(cfg, count /* e.g., 3 */) {
  // Fetch ALL team iterations, filter locally to last N past (finished before now), excluding current
  const all = listAllTeamIterations_(cfg);
  if (!all.length) return [];

  let currentId = null;
  try {
    const cur = getCurrentIteration_(cfg);
    currentId = cur && cur.id;
  } catch (e) { /* ignore */ }

  const now = new Date();
  const past = all.filter(it => new Date(it.attributes.finishDate) < now && it.id !== currentId);
  past.sort((a,b)=> new Date(b.attributes.startDate) - new Date(a.attributes.startDate));
  return past.slice(0, Math.max(0, count));
}

function listAllTeamIterations_(cfg) {
  // No timeframe filter — avoids 400s on some orgs
  const url = `https://dev.azure.com/${enc(cfg.org)}/${enc(cfg.projectId)}/${enc(cfg.team)}` +
              `/_apis/work/teamsettings/iterations?api-version=7.1-preview.1`;
  const res = adoFetch_(cfg, url, "GET");
  return res.value || [];
}

function getCurrentIteration_(cfg) {
  const url = `https://dev.azure.com/${enc(cfg.org)}/${enc(cfg.projectId)}/${enc(cfg.team)}` +
              `/_apis/work/teamsettings/iterations?$timeframe=current&api-version=7.1-preview.1`;
  const res = adoFetch_(cfg, url, "GET");
  const list = res.value || [];
  if (!list.length) throw new Error("No current iteration found. Check your Team selection in DevOps.");
  return list[0];
}

/** ============== DevOps API & Work Items ============== **/
function getTeamDaysOff_(cfg, iterationId) {
  const url = `https://dev.azure.com/${enc(cfg.org)}/${enc(cfg.projectId)}/${enc(cfg.team)}` +
              `/_apis/work/teamsettings/iterations/${enc(iterationId)}/teamdaysoff?api-version=7.1-preview.1`;
  const res = adoFetch_(cfg, url, "GET");
  const ranges = (res.daysOff || []).flatMap(r => expandDateRange_(r.start, r.end));
  return new Set(ranges.map(d => fmtDateKey_(d)));
}

function getCapacityByUser_(cfg, iterationId, sprintStart, sprintEnd, teamDayOffSet) {
  const url = `https://dev.azure.com/${enc(cfg.org)}/${enc(cfg.projectId)}/${enc(cfg.team)}` +
              `/_apis/work/teamsettings/iterations/${enc(iterationId)}/capacities?api-version=7.1-preview.1`;
  const res = adoFetch_(cfg, url, "GET");
  const values = res.value || [];
  const workingDates = enumerateWorkingDatesTeamAware_(sprintStart, sprintEnd, teamDayOffSet);

  const out = {};
  for (const entry of values) {
    const member = entry.teamMember || {};
    const name = canonicalName_(member.displayName || member.uniqueName || "");
    if (!name) continue;

    let capacityPerDay = 0;
    for (const a of (entry.activities || [])) capacityPerDay += toNumber_(a.capacityPerDay);

    const personalDays = (entry.daysOff || []).flatMap(r => expandDateRange_(r.start, r.end))
                        .filter(isWeekday_).map(fmtDateKey_);
    const personalOffSet = new Set(personalDays);

    let effectiveDays = 0;
    for (const d of workingDates) if (!personalOffSet.has(fmtDateKey_(d))) effectiveDays++;
    const effectiveCapacity = round2_(capacityPerDay * effectiveDays);

    out[name] = {
      capacityPerDay: round2_(capacityPerDay),
      workingDays: workingDates.length,
      daysOffCount: personalOffSet.size,
      effectiveCapacity,
      workingDates,
      personalOffSet
    };
  }
  return out;
}

function queryWorkItemIdsForIteration_(cfg, iterationPath, types /*array*/) {
  const typesClause = types.map(t => `'${t}'`).join(",");
  const wiql = {
    query:
      `SELECT [System.Id] FROM WorkItems ` +
      `WHERE [System.IterationPath] UNDER '${escapeQuotes_(iterationPath)}' ` +
      `AND [System.WorkItemType] IN (${typesClause})`
  };
  const url = `https://dev.azure.com/${enc(cfg.org)}/${enc(cfg.projectId)}` +
              `/_apis/wit/wiql?api-version=7.1-preview.2`;
  const res = adoFetch_(cfg, url, "POST", wiql);
  const workItems = res.workItems || [];
  return workItems.map(w => w.id);
}

function fetchWorkItemsBatch_(cfg, ids, fields) {
  if (!ids || !ids.length) return [];
  const chunks = chunk_(ids, 180);
  const out = [];
  for (const group of chunks) {
    const url = `https://dev.azure.com/${enc(cfg.org)}/${enc(cfg.projectId)}` +
                `/_apis/wit/workitemsbatch?api-version=7.1-preview.1`;
    const payload = { ids: group, fields: fields };
    const res = adoFetch_(cfg, url, "POST", payload);
    const values = res.value || [];
    const byId = {};
    for (const it of values) byId[it.id] = it;
    for (const id of group) if (byId[id]) out.push(byId[id]);
  }
  return out;
}

function adoFetch_(cfg, url, method, payload) {
  const headers = {
    "Content-Type": "application/json",
    "Authorization": "Basic " + Utilities.base64Encode(":" + cfg.pat)
  };
  const params = { method: method || "GET", headers, muteHttpExceptions: true };
  if (payload != null) params.payload = JSON.stringify(payload);

  const resp = UrlFetchApp.fetch(url, params);
  const code = resp.getResponseCode();
  const text = resp.getContentText();
  if (code >= 200 && code < 300) return text ? JSON.parse(text) : {};
  throw new Error(`ADO ${method || "GET"} failed (${code}): ${text}`);
}

/** ============== Calculations & Dates ============== **/
function computeStatus_({ state, progressPct, expectedPct, dueDate, startDate }) {
  if (!startDate || !dueDate) return "Values Missing";
  if ((state || "").toLowerCase() === "done" || progressPct >= 99) return "Completed";
  const today = todayMidnight_();
  if (dueDate && ymd_(dueDate) < ymd_(today)) return "Overdue";
  if (progressPct < (expectedPct - 15)) return "At Risk";
  return "On Track";
}
function progressPercent_(effort, remaining, state) {
  const st = (state || "").toLowerCase();
  if (!effort && st === "done") return 100;
  if (!effort) return 0;
  const used = Math.max(0, (effort || 0) - (remaining || 0));
  return Math.min(100, Math.max(0, (used / effort) * 100));
}
function expectedPercentWorkingDays_(today, workingDates) {
  if (!workingDates || !workingDates.length) return 0;
  const t = new Date(today); t.setHours(0,0,0,0);
  const elapsed = workingDates.filter(d => d <= t).length;
  return Math.min(100, Math.max(0, (elapsed / workingDates.length) * 100));
}
function enumerateWorkingDatesTeamAware_(start, end, teamDayOffSet) {
  const out = [];
  const s = new Date(start.getFullYear(), start.getMonth(), start.getDate());
  const e = new Date(end.getFullYear(), end.getMonth(), end.getDate());
  for (let d = s; d <= e; d = addDays_(d, 1)) {
    const dd = new Date(d);
    if (isWeekday_(dd) && !teamDayOffSet.has(fmtDateKey_(dd))) out.push(dd);
  }
  return out;
}

/** ============== Sheets: write & style ============== **/
function upsertSheet_(name, headers, rows) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(name) || ss.insertSheet(name);
  sh.clearFormats(); sh.clearContents();
  if (headers && headers.length) sh.appendRow(headers);
  if (rows && rows.length) sh.getRange(2, 1, rows.length, headers.length).setValues(rows);
  sh.autoResizeColumns(1, Math.max(1, headers.length));
}
function applyTableStyle_(sheetName) {
  const sh = SpreadsheetApp.getActive().getSheetByName(sheetName);
  if (!sh) return;
  const lastRow = Math.max(1, sh.getLastRow());
  const lastCol = Math.max(1, sh.getLastColumn());
  sh.setFrozenRows(1);

  const header = sh.getRange(1, 1, 1, lastCol);
  header.setBackground(THEME_HEADER_BG).setFontWeight("bold").setHorizontalAlignment("center");

  const rng = sh.getRange(1, 1, lastRow, lastCol);
  rng.setBorder(true, true, true, true, true, true);

  const bandings = sh.getBandings ? sh.getBandings() : [];
  bandings.forEach(b => b.remove());
  if (lastRow > 2) sh.getRange(2, 1, lastRow - 1, lastCol).applyRowBanding(THEME_ROW_BAND);
}
function applyStatusColorRules_(sheetName, statusColIndex) {
  const sh = SpreadsheetApp.getActive().getSheetByName(sheetName);
  if (!sh) return;
  const lastRow = Math.max(2, sh.getLastRow());
  if (lastRow < 2) return;
  const statusRange = sh.getRange(2, statusColIndex, lastRow - 1, 1);
  const existing = sh.getConditionalFormatRules() || [];
  const keep = existing.filter(r => {
    const ranges = r.getRanges().map(x => x.getA1Notation()).join(",");
    return !ranges.includes(statusRange.getA1Notation());
  });
  const newRules = [
    SpreadsheetApp.newConditionalFormatRule().setRanges([statusRange]).whenTextEqualTo("Overdue")
      .setBackground("#f44336").setFontColor("#ffffff").build(),
    SpreadsheetApp.newConditionalFormatRule().setRanges([statusRange]).whenTextEqualTo("Completed")
      .setBackground("#388e3c").setFontColor("#ffffff").build(),
    SpreadsheetApp.newConditionalFormatRule().setRanges([statusRange]).whenTextEqualTo("On Track")
      .setBackground("#1e88e5").setFontColor("#ffffff").build(),
    SpreadsheetApp.newConditionalFormatRule().setRanges([statusRange]).whenTextEqualTo("At Risk")
      .setBackground("#f9a825").setFontColor("#000000").build(),
    SpreadsheetApp.newConditionalFormatRule().setRanges([statusRange]).whenTextEqualTo("Values Missing")
      .setBackground("#9e9e9e").setFontColor("#ffffff").build()
  ];
  sh.setConditionalFormatRules(keep.concat(newRules));
}
function stampSprintBanner_(sheetName, sprintName, sprintStart, sprintEnd) {
  const sh = SpreadsheetApp.getActive().getSheetByName(sheetName);
  if (!sh) return;
  sh.getRange("A1").setValue(`Sprint: ${sprintName}`);
  sh.getRange("B1").setValue(`Start: ${new Date(sprintStart).toDateString()}`);
  sh.getRange("C1").setValue(`End: ${new Date(sprintEnd).toDateString()}`);
  sh.getRange("D1").setValue(`Last Updated: ${new Date().toLocaleString("en-GB")}`);
}

/** ============== Capacity (Per-Day) builder ============== **/
function buildCapacityPerDayFromApi_(tabName, workingDates, capacityByUser, rollup) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(tabName) || ss.insertSheet(tabName);
  sh.clearFormats();
  sh.clearContents();

  const dateFmt = (d)=> Utilities.formatDate(d, Session.getScriptTimeZone(), "EEE dd-MMM");
  const dateHeaders = workingDates.map(dateFmt);
  const headers = ["Name of Resource","Role","Capacity per Day (hrs)"]
                  .concat(dateHeaders)
                  .concat(["Effective Sprint Capacity","Planned Hours","Allocation % (planned/capacity)","Utilization Rate (actual/capacity)","Actual Hours Spent","Remaining Hours","% Progress"]);
  sh.appendRow(headers);

  // union of names from capacity and rollup
  const unionNames = new Set(Object.keys(capacityByUser).concat(Object.keys(rollup || {})));
  const people = Array.from(unionNames).sort((a,b)=>a.localeCompare(b));
  const rows = [];

  for (const person of people) {
    const cap = capacityByUser[person] || {};
    const capPerDay = cap.capacityPerDay || 0;
    const personalOff = cap.personalOffSet || new Set();

    // Per-working-day capacity (0 on personal day-off)
    const perDay = workingDates.map(d => personalOff.has(fmtDateKey_(d)) ? 0 : capPerDay);

    const r = rollup[person] || { planned: 0, actual: 0, remaining: 0 };
    const planned = round2_(r.planned), actual = round2_(r.actual), remaining = round2_(r.remaining);
    const effCap  = round2_((cap.effectiveCapacity != null ? cap.effectiveCapacity : perDay.reduce((a,b)=>a+b,0)));
    const allocation = effCap ? round2_(planned/effCap*100) : 0;
    const utilRate   = effCap ? round2_(actual /effCap*100) : 0;
    const progress   = planned ? round2_(actual/planned*100) : 0;

    rows.push([person,"", round2_(capPerDay)].concat(perDay).concat([effCap, planned, allocation, utilRate, actual, remaining, progress]));
  }

  if (rows.length) sh.getRange(2,1,rows.length,headers.length).setValues(rows);
  sh.autoResizeColumns(1, headers.length);
}

/** ============== Small utils ============== **/
function enc(s){ return encodeURIComponent(s); }
function escapeQuotes_(s){ return String(s).replace(/'/g, "''"); }
function canonicalName_(s){ if(!s) return ""; return String(s).replace(/\s*<[^>]+>\s*$/, "").trim(); }
function extractAssignee_(assigneeField){
  let raw = "";
  if (!assigneeField) return "";
  if (typeof assigneeField === "string") raw = assigneeField;
  else if (assigneeField.displayName)   raw = assigneeField.displayName;
  else if (assigneeField.uniqueName)    raw = assigneeField.uniqueName;
  return canonicalName_(raw);
}
function toNumber_(v){ const n = Number(v); return isNaN(n) ? 0 : n; }
function pickNumber_(a,b){ const aa = toNumber_(a); return aa ? aa : toNumber_(b); }
function toDateOrNull_(v){ if(!v) return null; const d = new Date(v); return isNaN(d.getTime()) ? null : d; }
function asDateValue_(d){ return d ? new Date(d) : ""; }
function todayMidnight_(){ const t = new Date(); t.setHours(0,0,0,0); return t; }
function ymd_(d){ return d.getFullYear()*10000 + (d.getMonth()+1)*100 + d.getDate(); }
function round2_(n){ return Math.round((n + Number.EPSILON)*100)/100; }
function sortBy_(rows, colIndex){ return rows.sort((a,b)=>{ const x=(a[colIndex]||"").toString().toLowerCase(); const y=(b[colIndex]||"").toString().toLowerCase(); return x<y?-1:x>y?1:0; }); }
function chunk_(arr, size){ const out=[]; for (let i=0;i<arr.length;i+=size) out.push(arr.slice(i, i+size)); return out; }
function fmtDateKey_(d){ const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,"0"); const day=String(d.getDate()).padStart(2,"0"); return `${y}-${m}-${day}`; }
function expandDateRange_(startISO, endISO){
  if (!startISO || !endISO) return [];
  const s = new Date(startISO), e = new Date(endISO);
  s.setHours(0,0,0,0); e.setHours(0,0,0,0);
  const out = [];
  for (let d = new Date(s); d <= e; d = addDays_(d, 1)) out.push(new Date(d));
  return out;
}
function isWeekday_(d){ const day = d.getDay(); return day !== 0 && day !== 6; }
function addDays_(d,n){ const x = new Date(d); x.setDate(x.getDate()+n); return x; }

/** ---------- Remaining Log helper ---------- **/
function buildLastRemainingMap_(sh) {
  const lastRow = sh.getLastRow();
  const out = {};
  if (lastRow < 2) return out;
  const range = sh.getRange(2, 1, lastRow-1, 6).getValues();
  for (let i=0;i<range.length;i++) {
    const row = range[i];
    const id = String(row[1] || "");
    const rem = toNumber_(row[4]);
    if (!id) continue;
    out[id] = rem; // last wins
  }
  return out;
}
