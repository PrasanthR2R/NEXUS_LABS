/*******************************
 * Azure DevOps → Google Sheets (Selector-enabled, auto-refresh, with Daily Utilization)
 * Tabs: Tasks, Bugs, Resource Summary, Capacity (Per-Day), Remaining_Log, Daily Utilization
 * Entry points:
 *   - setupSprintSelector()  ← run once to create dropdown (Current + last 3)
 *   - runSprintReport_Selected()
 *   - runSprintReport_Current()
 *   - enableSprintAutoRefresh() / disableSprintAutoRefresh()
 *   - snapshotRemainingLog_Current()
 *   - runDailyUtilizationReport_Current() / _Selected()
 *   - installEvery2hAutomation() / uninstallAutomation()
 *******************************/

// ==== HARD-CODED CONFIG (Turbo Max CRM) ====
const ADO_ORG        = "Clictell";
const ADO_PROJECT_ID = "0b0a27a1-82bc-4fee-b3fe-cccbfb1a3164"; // Turbo Max CRM (GUID)
const ADO_TEAM       = "Turbo Max CRM Team";                   // EXACT team name as in Boards → Teams
const ADO_PAT        = ""; // test PAT

// Sheets & UI
const SHEET_SELECTOR = "Sprint Selector";
const SHEET_INDEX    = "_SprintIndex"; // hidden map Name↔Id/Path/Start/End

// UI theme
const THEME_HEADER_BG = "#e8cc86";

// === COMPLETED OVERRIDE (by State only — unconditional) ===
const COMPLETED_OVERRIDE_STATES = new Set([
  "done",
  "Ready to Production",
  "deployed on production",
  "approved"
].map(s => s.toLowerCase()));

/** ======================= MENU ======================= **/
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu("Sprint Report")
    .addItem("Setup Sprint Selector (Current + last 3)", "setupSprintSelector")
    .addItem("Refresh Selected Sprint", "runSprintReport_Selected")
    .addItem("Refresh Current Sprint", "runSprintReport_Current")
    .addSeparator()
    .addItem("Snapshot Remaining (Now)", "snapshotRemainingLog_Current")
    .addItem("Build Daily Utilization (Latest Snapshot)", "runDailyUtilizationReport_Current")
    .addSeparator()
    .addItem("Install 2h Orchestrator", "installEvery2hAutomation")
    .addItem("Uninstall 2h Orchestrator", "uninstallAutomation")
    .addSeparator()
    .addItem("Enable Auto-Refresh on Sprint Change", "enableSprintAutoRefresh")
    .addItem("Disable Auto-Refresh Trigger", "disableSprintAutoRefresh")
    .addToUi();
}

/** =================== ENTRY POINTS =================== **/

function runSprintReport_Current() {
  const cfg = { org: ADO_ORG, projectId: ADO_PROJECT_ID, team: ADO_TEAM, pat: ADO_PAT };
  const iteration = getCurrentIteration_(cfg);
  runSprintReport_ForIteration_(cfg, iteration);
}

function setupSprintSelector() {
  const cfg = { org: ADO_ORG, projectId: ADO_PROJECT_ID, team: ADO_TEAM, pat: ADO_PAT };

  const current = safeGetCurrentIteration_(cfg);
  const past3 = safeGetPastIterations_(cfg, 3);

  const list = [];
  if (current) list.push(current);
  list.push.apply(list, past3);
  list.sort((a,b)=> new Date(b.attributes.startDate) - new Date(a.attributes.startDate));

  const ss = SpreadsheetApp.getActive();
  const idx = ss.getSheetByName(SHEET_INDEX) || ss.insertSheet(SHEET_INDEX);
  idx.clear();
  idx.appendRow(["Name","ID","Path","Start","End"]);
  list.forEach(it => {
    idx.appendRow([
      it.name, it.id, it.path,
      new Date(it.attributes.startDate), new Date(it.attributes.finishDate)
    ]);
  });
  idx.hideSheet();

  const sh = ss.getSheetByName(SHEET_SELECTOR) || ss.insertSheet(SHEET_SELECTOR);
  sh.clear();
  sh.appendRow(["Selected Sprint", "Pick a sprint name"]);
  sh.setFrozenRows(1);
  const namesRange = idx.getRange(2,1,Math.max(0, idx.getLastRow()-1),1);
  if (namesRange.getNumRows() > 0) {
    const rule = SpreadsheetApp.newDataValidation()
      .requireValueInRange(namesRange, true)
      .setAllowInvalid(false)
      .build();
    sh.getRange("B2").setDataValidation(rule);
    sh.getRange("B2").setValue(idx.getRange(2,1).getValue()); // preselect first
  } else {
    sh.getRange("B2").setValue("No sprints found");
  }
  styleHeaderRow_(SHEET_SELECTOR);
  wrapHeaderFirstCol_(SHEET_SELECTOR);

  runSprintReport_Selected();
}

function runSprintReport_Selected() {
  const cfg = { org: ADO_ORG, projectId: ADO_PROJECT_ID, team: ADO_TEAM, pat: ADO_PAT };
  const ss = SpreadsheetApp.getActive();
  const sel = ss.getSheetByName(SHEET_SELECTOR);
  const idx = ss.getSheetByName(SHEET_INDEX);
  if (!sel || !idx) return;

  // Stabilized: find the editable selector cell by header map (not hardcoded B2)
  const H = headerIndexMap_(sel);
  const pickCol = (H["Pick a sprint name"] != null) ? (H["Pick a sprint name"] + 1) : 2;
  const name = (sel.getRange(2, pickCol).getDisplayValue() || "").trim();
  if (!name || name === "No sprints found") return;

  const rows = idx.getRange(2,1,Math.max(0, idx.getLastRow()-1),5).getValues();
  const rec = rows.find(r => String(r[0]).trim() === name);
  if (!rec) return;

  const iteration = {
    name: rec[0], id: rec[1], path: rec[2],
    attributes: { startDate: rec[3], finishDate: rec[4] }
  };
  runSprintReport_ForIteration_(cfg, iteration);
}

/** ============== AUTO-REFRESH TRIGGER ============== **/

function enableSprintAutoRefresh() {
  removeSprintAutoRefreshTriggers_();
  ScriptApp.newTrigger("onSprintSelectEdit")
    .forSpreadsheet(SpreadsheetApp.getActive())
    .onEdit()
    .create();
}

function disableSprintAutoRefresh() {
  removeSprintAutoRefreshTriggers_();
}

function removeSprintAutoRefreshTriggers_() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === "onSprintSelectEdit") {
      ScriptApp.deleteTrigger(t);
    }
  });
}

function onSprintSelectEdit(e) {
  try {
    if (!e) return;
    const range = e.range;
    const sh = range.getSheet();
    if (sh.getName() !== SHEET_SELECTOR) return;

    // Stabilized: detect the "Pick a sprint name" column dynamically
    const H = headerIndexMap_(sh);
    const pickCol = (H["Pick a sprint name"] != null) ? (H["Pick a sprint name"] + 1) : 2;

    if (range.getRow() === 2 && range.getColumn() === pickCol) {
      runSprintReport_Selected();
    }
  } catch (err) {
    Logger.log("onSprintSelectEdit error: " + err);
  }
}

/** ============== CORE REPORT (by iteration) ============== **/
function runSprintReport_ForIteration_(cfg, iteration) {
  const sprintName = iteration.name;
  const sprintPath = iteration.path;
  const sprintStart = new Date(iteration.attributes.startDate);
  const sprintEnd   = new Date(iteration.attributes.finishDate);

  const teamDayOffSet = getTeamDaysOff_(cfg, iteration.id);
  const workingDates  = enumerateWorkingDatesTeamAware_(sprintStart, sprintEnd, teamDayOffSet);

  // Capacity
  let capacityByUser = {};
  try {
    capacityByUser = getCapacityByUser_(cfg, iteration.id, sprintStart, sprintEnd, teamDayOffSet);
  } catch (e) {
    capacityByUser = {};
  }

  // Work items
  const ids = queryWorkItemIdsForIteration_(cfg, sprintPath, ["Task","Bug"]);
  const fields = [
    "System.Id","System.WorkItemType","System.Title","System.State","Microsoft.VSTS.Common.Priority",
    "System.AssignedTo","Microsoft.VSTS.Scheduling.Effort","Microsoft.VSTS.Scheduling.OriginalEstimate",
    "Microsoft.VSTS.Scheduling.RemainingWork","Microsoft.VSTS.Scheduling.StartDate","Microsoft.VSTS.Scheduling.DueDate",
    "Microsoft.VSTS.Common.ClosedDate","Microsoft.VSTS.Common.Activity"
  ];
  const items = fetchWorkItemsBatch_(cfg, ids, fields);

  const rowsTasks = [];
  const rowsBugs  = [];
  const rollup = {};
  const today = todayMidnight_();

  for (const wi of items) {
    const f = wi.fields || {};
    const theId = wi.id || "";
    const type = (f["System.WorkItemType"] || "").toString();
    const typeLc = type.toLowerCase();
    const title = f["System.Title"] || "";
    const state = f["System.State"] || "";
    const stateLc = (state || "").toLowerCase();
    const priority = toNumber_(f["Microsoft.VSTS.Common.Priority"]);
    const assignedTo = extractAssignee_(f["System.AssignedTo"]);
    const effort = pickNumber_(f["Microsoft.VSTS.Scheduling.Effort"], f["Microsoft.VSTS.Scheduling.OriginalEstimate"]);
    const remaining = toNumber_(f["Microsoft.VSTS.Scheduling.RemainingWork"]);
    const startDate = toDateOrNull_(f["Microsoft.VSTS.Scheduling.StartDate"]);
    const dueDate   = toDateOrNull_(f["Microsoft.VSTS.Scheduling.DueDate"]);
    const closedDate= toDateOrNull_(f["Microsoft.VSTS.Common.ClosedDate"]);
    const activity  = f["Microsoft.VSTS.Common.Activity"] || "";

    const progressPct = progressPercent_(effort, remaining, state);
    const utilized    = Math.min((effort || 0), Math.max(0, (effort || 0) - (remaining || 0)));

    // === EXPECTED / STATUS ===
    const exp = computeTicketExpected_(effort, startDate, dueDate, iteration.attributes.startDate, iteration.attributes.finishDate, teamDayOffSet);

    const completedOverride = COMPLETED_OVERRIDE_STATES.has(stateLc); // <-- unconditional by State
    const status = computeStatusTicketAware_({
      state,
      progressPct,
      today,
      dueDateResolved: exp.resolvedDue,
      effort,
      remaining,
      expectedRemaining: exp.expectedRemaining,
      graceHours: exp.graceHours,
      missingBothDates: exp.missingBoth,
      usedSprintStart: exp.usedSprintStart,
      usedSprintEnd: exp.usedSprintEnd,
      completedOverride
    });

    const row = [
      theId, type, title, assignedTo, state, priority,
      effort, remaining, round2_(utilized),
      asDateValue_(startDate), asDateValue_(dueDate), asDateValue_(closedDate),
      activity, round2_(progressPct), round2_(exp.expectedPct), status
    ];
    if (typeLc === "bug") rowsBugs.push(row); else rowsTasks.push(row);

    if (assignedTo) {
      rollup[assignedTo] = rollup[assignedTo] || { planned: 0, actual: 0, remaining: 0 };
      rollup[assignedTo].planned   += (effort || 0);
      rollup[assignedTo].actual    += utilized;
      rollup[assignedTo].remaining += (remaining || 0);
    }
  }

  // === Write Tasks / Bugs ===
  const headers = [
    "ID","Work Item Type","Title","Assigned To","State","Priority",
    "Effort","Remaining","Utilized","Start Date","Due Date","Closed Date",
    "Activity","Progress %","Expected %","Status"
  ];
  upsertSheet_("Tasks", headers, rowsTasks);
  styleHeaderRow_("Tasks"); wrapHeaderFirstCol_("Tasks");
  applyStatusColorRules_("Tasks", 16);
  applyPercentFormats_("Tasks", [14,15]); // 0..100 values, display with "%"
  applyNumberFormats_("Tasks", [7,8,9]); // Effort, Remaining, Utilized

  upsertSheet_("Bugs", headers, rowsBugs);
  styleHeaderRow_("Bugs"); wrapHeaderFirstCol_("Bugs");
  applyStatusColorRules_("Bugs", 16);
  applyPercentFormats_("Bugs", [14,15]);
  applyNumberFormats_("Bugs", [7,8,9]);

  // === Resource Summary ===
  const resRows = [];
  const allPeople = new Set(Object.keys(rollup).concat(Object.keys(capacityByUser)));
  for (const person of allPeople) {
    const r = rollup[person] || { planned: 0, actual: 0, remaining: 0 };
    const capObj = capacityByUser[person] || {
      capacityPerDay: 0, workingDays: workingDates.length, daysOffCount: 0, effectiveCapacity: 0
    };
    const planned = r.planned, actual = r.actual, remaining = r.remaining, effCap = capObj.effectiveCapacity || 0;

    const progressPctPerson = planned > 0 ? (actual/planned*100) : 0;
    const allocationPct     = effCap > 0 ? (planned/effCap*100) : "—"; // Patch B
    const utilizationPct    = effCap > 0 ? (actual/effCap*100) : "—";   // Patch B

    resRows.push([
      person, sprintName,
      round2_(capObj.capacityPerDay || 0),
      capObj.workingDays || 0,
      capObj.daysOffCount || 0,
      round2_(effCap),
      round2_(planned),
      round2_(actual),
      round2_(remaining),
      round2_(progressPctPerson),
      (typeof allocationPct === "number" ? round2_(allocationPct) : "—"),
      (typeof utilizationPct === "number" ? round2_(utilizationPct) : "—")
    ]);
  }

  const resHeaders = [
    "Resource","Sprint","Capacity per Day (hrs)","Working Days","Days Off (days)","Effective Sprint Capacity (hrs)",
    "Planned Hours/Assigned Task Hours (Σ Effort)","Actual Hours Spent (Σ Utilized)","Remaining Hours (Σ Remaining)",
    "Progress % (Actual/Planned)","Allocation % (Planned/Capacity)","Utilization % (Actual/Capacity)"
  ];
  upsertSheet_("Resource Summary", resHeaders, sortBy_(resRows, 0));
  styleHeaderRow_("Resource Summary"); wrapHeaderFirstCol_("Resource Summary");
  applyPercentFormats_("Resource Summary", [10,11,12]);
  applyNumberFormats_("Resource Summary", [3,4,6,7,8]); // numbers/hours

  // === Capacity (Per-Day) ===
  buildCapacityPerDayFromApi_("Capacity (Per-Day)", workingDates, capacityByUser, rollup);
  styleHeaderRow_("Capacity (Per-Day)"); wrapHeaderFirstCol_("Capacity (Per-Day)");
  const capSheet = SpreadsheetApp.getActive().getSheetByName("Capacity (Per-Day)");
  if (capSheet) {
    // Header-safe % formatting (no brittle col math)
    applyPercentFormatsByHeader_("Capacity (Per-Day)", [
      "Allocation % (planned/capacity)",
      "Utilization Rate (actual/capacity)",
      "% Progress"
    ]);

    // ---- Patch A: DO NOT overwrite those % formats. Format only numeric columns.
    applyNumberFormatsByHeader_("Capacity (Per-Day)", [
      "Capacity per Day (hrs)",
      "Effective Sprint Capacity",
      "Planned Hours",
      "Actual Hours Spent",
      "Remaining Hours"
    ]);

    // Per-day date columns (only the middle block) as numbers
    const lastCol = capSheet.getLastColumn();
    const lastRow = capSheet.getLastRow();
    const firstDateCol = 4;                 // Name, Role, Capacity = 1..3
    const trailingSummaryCols = 7;          // EffectiveCap..% Progress = 7 cols
    const lastDateCol = lastCol - trailingSummaryCols;
    if (lastRow > 1 && lastDateCol >= firstDateCol) {
      capSheet.getRange(2, firstDateCol, lastRow-1, lastDateCol-firstDateCol+1).setNumberFormat("0.00");
    }
  }

  // Banners
  stampSprintBanner_("Tasks", sprintName, sprintStart, sprintEnd, { showStart:true, showEnd:true, showLastUpdated:true });
  stampSprintBanner_("Bugs", sprintName, sprintStart, sprintEnd, { showStart:true, showEnd:true, showLastUpdated:true });
  stampSprintBanner_("Resource Summary", sprintName, sprintStart, sprintEnd, { showStart:true, showEnd:false, showLastUpdated:false });
  stampSprintBanner_("Capacity (Per-Day)", sprintName, sprintStart, sprintEnd, { showStart:true, showEnd:true, showLastUpdated:true });

  // ✨ Post-banner patch: keep visible headers for Resource Summary C & D
  const rs = SpreadsheetApp.getActive().getSheetByName("Resource Summary");
  if (rs) {
    rs.getRange(1, 3).setValue("Capacity per Day (hrs)"); // C1
    rs.getRange(1, 4).setValue("Working Days");           // D1
  }
}

/** ============== Iteration lookup helpers (timeframe-safe) ============== **/
function safeGetCurrentIteration_(cfg) {
  try { return getCurrentIteration_(cfg); } catch(e) { return null; }
}

function safeGetPastIterations_(cfg, count) {
  const all = listAllTeamIterations_(cfg);
  if (!all.length) return [];
  let currentId = null;
  try { const cur = getCurrentIteration_(cfg); currentId = cur && cur.id; } catch (e) {}
  const now = new Date();
  const past = all.filter(it => new Date(it.attributes.finishDate) < now && it.id !== currentId);
  past.sort((a,b)=> new Date(b.attributes.startDate) - new Date(a.attributes.startDate));
  return past.slice(0, Math.max(0, count));
}

// ✅ FIXED: pagination via x-ms-continuationtoken to fetch ALL iterations
function listAllTeamIterations_(cfg) {
  const base = `https://dev.azure.com/${enc(cfg.org)}/${enc(cfg.projectId)}/${enc(cfg.team)}` +
               `/_apis/work/teamsettings/iterations?api-version=7.1-preview.1`;
  let url = base, out = [];
  while (true) {
    const resp = UrlFetchApp.fetch(url, {
      method: "GET",
      headers: {
        "Authorization": "Basic " + Utilities.base64Encode(":" + cfg.pat)
      },
      muteHttpExceptions: true
    });
    const code = resp.getResponseCode();
    const text = resp.getContentText() || "";
    if (code < 200 || code >= 300) throw new Error(`Iterations failed (${code}): ${text}`);
    const data = text ? JSON.parse(text) : {};
    out = out.concat(data.value || []);
    const headers = resp.getHeaders() || {};
    const tok = headers['x-ms-continuationtoken'] || headers['X-MS-ContinuationToken'];
    if (!tok) break;
    url = base + `&continuationToken=${encodeURIComponent(tok)}`;
  }
  return out;
}

function getCurrentIteration_(cfg) {
  const url = `https://dev.azure.com/${enc(cfg.org)}/${enc(cfg.projectId)}/${enc(cfg.team)}` +
              `/_apis/work/teamsettings/iterations?$timeframe=current&api-version=7.1-preview.1`;
  const res = adoFetch_(cfg, url, "GET");
  const list = res.value || [];
  if (!list.length) throw new Error("No current iteration found. Check your Team selection in DevOps.");
  return list[0];
}

/** ============== DevOps API & Work Items ============== **/
function getTeamDaysOff_(cfg, iterationId) {
  const url = `https://dev.azure.com/${enc(cfg.org)}/${enc(cfg.projectId)}/${enc(cfg.team)}` +
              `/_apis/work/teamsettings/iterations/${enc(iterationId)}/teamdaysoff?api-version=7.1-preview.1`;
  const res = adoFetch_(cfg, url, "GET");
  const ranges = (res.daysOff || []).flatMap(r => expandDateRange_(r.start, r.end));
  return new Set(ranges.map(d => fmtDateKey_(d)));
}

function getCapacityByUser_(cfg, iterationId, sprintStart, sprintEnd, teamDayOffSet) {
  const url = `https://dev.azure.com/${enc(cfg.org)}/${enc(cfg.projectId)}/${enc(cfg.team)}` +
              `/_apis/work/teamsettings/iterations/${enc(iterationId)}/capacities?api-version=7.1-preview.1`;
  const res = adoFetch_(cfg, url, "GET");
  const values = res.value || [];
  const workingDates = enumerateWorkingDatesTeamAware_(sprintStart, sprintEnd, teamDayOffSet);

  const out = {};
  for (const entry of values) {
    const member = entry.teamMember || {};
    const name = canonicalName_(member.displayName || member.uniqueName || "");
    if (!name) continue;

    let capacityPerDay = 0;
    for (const a of (entry.activities || [])) capacityPerDay += toNumber_(a.capacityPerDay);

    const personalDays = (entry.daysOff || []).flatMap(r => expandDateRange_(r.start, r.end))
                        .filter(isWeekday_).map(fmtDateKey_);
    const personalOffSet = new Set(personalDays);

    let effectiveDays = 0;
    for (const d of workingDates) if (!personalOffSet.has(fmtDateKey_(d))) effectiveDays++;
    const effectiveCapacity = round2_(capacityPerDay * effectiveDays);

    out[name] = {
      capacityPerDay: round2_(capacityPerDay),
      workingDays: workingDates.length,
      daysOffCount: personalOffSet.size,
      effectiveCapacity,
      workingDates,
      personalOffSet
    };
  }
  return out;
}

function queryWorkItemIdsForIteration_(cfg, iterationPath, types) {
  const typesClause = types.map(t => `'${t}'`).join(",");
  const wiql = {
    query:
      `SELECT [System.Id] FROM WorkItems ` +
      `WHERE [System.IterationPath] UNDER '${escapeQuotes_(iterationPath)}' ` +
      `AND [System.WorkItemType] IN (${typesClause})`
  };
  const url = `https://dev.azure.com/${enc(cfg.org)}/${enc(cfg.projectId)}` +
              `/_apis/wit/wiql?api-version=7.1-preview.2`;
  const res = adoFetch_(cfg, url, "POST", wiql);
  const workItems = res.workItems || [];
  return workItems.map(w => w.id);
}

function fetchWorkItemsBatch_(cfg, ids, fields) {
  if (!ids || !ids.length) return [];
  const chunks = chunk_(ids, 180);
  const out = [];
  for (const group of chunks) {
    const url = `https://dev.azure.com/${enc(cfg.org)}/${enc(cfg.projectId)}` +
                `/_apis/wit/workitemsbatch?api-version=7.1-preview.1`;
    const payload = { ids: group, fields: fields };
    const res = adoFetch_(cfg, url, "POST", payload);
    const values = res.value || [];
    const byId = {};
    for (const it of values) byId[it.id] = it;
    for (const id of group) if (byId[id]) out.push(byId[id]);
  }
  return out;
}

function adoFetch_(cfg, url, method, payload) {
  const headers = {
    "Content-Type": "application/json",
    "Authorization": "Basic " + Utilities.base64Encode(":" + cfg.pat)
  };
  const params = { method: method || "GET", headers, muteHttpExceptions: true };
  if (payload != null) params.payload = JSON.stringify(payload);

  const resp = UrlFetchApp.fetch(url, params);
  const code = resp.getResponseCode();
  const text = resp.getContentText();
  if (code >= 200 && code < 300) return text ? JSON.parse(text) : {};
  throw new Error(`ADO ${method || "GET"} failed (${code}): ${text}`);
}

/** ============== Calculations & Dates ============== **/

// FIXED: check both-missing BEFORE fallbacks
function computeTicketExpected_(effort, startDate, dueDate, sprintStartISO, sprintEndISO, teamDayOffSet) {
  const today = todayMidnight_();
  const hasStart = !!startDate && !isNaN(new Date(startDate).getTime());
  const hasDue   = !!dueDate   && !isNaN(new Date(dueDate).getTime());

  if (!hasStart && !hasDue) {
    return {
      expectedPct: 0,
      expectedRemaining: round2_(toNumber_(effort)),
      graceHours: 0,
      resolvedStart: null,
      resolvedDue: null,
      usedSprintStart: false,
      usedSprintEnd: false,
      missingBoth: true
    };
  }

  let usedSprintStart = false, usedSprintEnd = false;
  const sprintStart = new Date(sprintStartISO);
  const sprintEnd   = new Date(sprintEndISO);

  const start = hasStart ? new Date(startDate) : (usedSprintStart = true, new Date(sprintStart));
  const due   = hasDue   ? new Date(dueDate)   : (usedSprintEnd   = true, new Date(sprintEnd));

  start.setHours(0,0,0,0);
  due.setHours(0,0,0,0);

  const dates = [];
  for (let d = new Date(start); d <= due; d = addDays_(d, 1)) {
    if (isWeekday_(d) && !teamDayOffSet.has(fmtDateKey_(d))) dates.push(new Date(d));
  }

  const totalDays = Math.max(1, dates.length);
  const daysElapsed = dates.filter(d => d <= today).length;

  const eff = toNumber_(effort);
  const pacePerDay = eff / totalDays;
  const burnedExpected = pacePerDay * daysElapsed;

  return {
    expectedPct: round2_(Math.min(100, Math.max(0, (daysElapsed / totalDays) * 100))),
    expectedRemaining: round2_(Math.max(0, eff - burnedExpected)),
    graceHours: round2_(pacePerDay),
    resolvedStart: start,
    resolvedDue: due,
    usedSprintStart,
    usedSprintEnd,
    missingBoth: false
  };
}

// ✅ TIDIED: remove redundant !dueDateResolved branch (it only hits when both missing)
function computeStatusTicketAware_({
  state, progressPct, today, dueDateResolved, effort, remaining, expectedRemaining, graceHours,
  missingBothDates, usedSprintStart, usedSprintEnd, completedOverride
}) {
  if (completedOverride) return "Completed!";
  const st = (state || "").toLowerCase();
  if (missingBothDates) return "Values Missing (no start/due)";
  if (st === "done" || progressPct >= 99) return "Completed";
  if (ymd_(dueDateResolved) < ymd_(today)) return "Overdue";

  const rem = toNumber_(remaining);
  const threshold = (expectedRemaining || 0) + (graceHours || 0);
  let label = (rem > threshold) ? "At Risk" : "On Track";

  const hints = [];
  if (usedSprintStart) hints.push("used sprint start");
  if (usedSprintEnd) hints.push("used sprint end");
  if (hints.length) label += ` (${hints.join(", ")})`;
  return label;
}

function progressPercent_(effort, remaining, state) {
  const st = (state || "").toLowerCase();
  if (!effort && st === "done") return 100;
  if (!effort) return 0;
  const used = Math.max(0, (effort || 0) - (remaining || 0));
  return Math.min(100, Math.max(0, (used / effort) * 100));
}

function expectedPercentWorkingDays_(today, workingDates) {
  if (!workingDates || !workingDates.length) return 0;
  const t = new Date(today); t.setHours(0,0,0,0);
  const elapsed = workingDates.filter(d => d <= t).length;
  return Math.min(100, Math.max(0, (elapsed / workingDates.length) * 100));
}

function enumerateWorkingDatesTeamAware_(start, end, teamDayOffSet) {
  const out = [];
  const s = new Date(start.getFullYear(), start.getMonth(), start.getDate());
  const e = new Date(end.getFullYear(), end.getMonth(), end.getDate());
  for (let d = s; d <= e; d = addDays_(d, 1)) {
    const dd = new Date(d);
    if (isWeekday_(dd) && !teamDayOffSet.has(fmtDateKey_(dd))) out.push(dd);
  }
  return out;
}

/** ============== Sheets: write & style ============== **/
function upsertSheet_(name, headers, rows) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(name) || ss.insertSheet(name);
  sh.clearFormats(); sh.clearContents();
  if (headers && headers.length) sh.appendRow(headers);
  if (rows && rows.length) sh.getRange(2, 1, rows.length, headers.length).setValues(rows);
  sh.autoResizeColumns(1, Math.max(1, headers.length));
}

function styleHeaderRow_(sheetName) {
  const sh = SpreadsheetApp.getActive().getSheetByName(sheetName);
  if (!sh) return;
  const lastCol = Math.max(1, sh.getLastColumn());
  sh.setFrozenRows(1);
  const header = sh.getRange(1, 1, 1, lastCol);
  header.setBackground(THEME_HEADER_BG).setFontWeight("bold").setHorizontalAlignment("center");
  // Clear any banding – keep rows white
  const bandings = sh.getBandings ? sh.getBandings() : [];
  bandings.forEach(b => b.remove());
  // Border the whole used range
  const lastRow = Math.max(1, sh.getLastRow());
  sh.getRange(1, 1, lastRow, lastCol).setBorder(true, true, true, true, true, true);
}

function wrapHeaderFirstCol_(sheetName) {
  const sh = SpreadsheetApp.getActive().getSheetByName(sheetName);
  if (!sh) return;
  sh.getRange(1,1,1,1).setWrapStrategy(SpreadsheetApp.WrapStrategy.WRAP);
}

function applyStatusColorRules_(sheetName, statusColIndex) {
  const sh = SpreadsheetApp.getActive().getSheetByName(sheetName);
  if (!sh) return;
  const lastRow = Math.max(2, sh.getLastRow());
  if (lastRow < 2) return;
  const statusRange = sh.getRange(2, statusColIndex, lastRow - 1, 1);
  const existing = sh.getConditionalFormatRules() || [];
  const keep = existing.filter(r => {
    const ranges = r.getRanges().map(x => x.getA1Notation()).join(",");
    return !ranges.includes(statusRange.getA1Notation());
  });
  const newRules = [
    SpreadsheetApp.newConditionalFormatRule().setRanges([statusRange]).whenTextEqualTo("Overdue")
      .setBackground("#f44336").setFontColor("#ffffff").build(),
    SpreadsheetApp.newConditionalFormatRule().setRanges([statusRange]).whenTextContains("Completed")
      .setBackground("#388e3c").setFontColor("#ffffff").build(),
    SpreadsheetApp.newConditionalFormatRule().setRanges([statusRange]).whenTextEqualTo("On Track")
      .setBackground("#1e88e5").setFontColor("#ffffff").build(),
    SpreadsheetApp.newConditionalFormatRule().setRanges([statusRange]).whenTextEqualTo("At Risk")
      .setBackground("#f9a825").setFontColor("#000000").build(),
    SpreadsheetApp.newConditionalFormatRule().setRanges([statusRange]).whenTextContains("Values Missing")
      .setBackground("#9e9e9e").setFontColor("#ffffff").build()
  ];
  sh.setConditionalFormatRules(keep.concat(newRules));
}

function stampSprintBanner_(sheetName, sprintName, sprintStart, sprintEnd, opts) {
  const sh = SpreadsheetApp.getActive().getSheetByName(sheetName);
  if (!sh) return;
  const o = Object.assign({ showStart:true, showEnd:true, showLastUpdated:true }, opts || {});
  sh.getRange("A1").setValue(`Sprint: ${sprintName}`);
  if (o.showStart) sh.getRange("B1").setValue(`Start: ${new Date(sprintStart).toDateString()}`); else sh.getRange("B1").setValue("");
  if (o.showEnd)   sh.getRange("C1").setValue(`End: ${new Date(sprintEnd).toDateString()}`);    else sh.getRange("C1").setValue("");
  if (o.showLastUpdated) sh.getRange("D1").setValue(`Last Updated: ${new Date().toLocaleString("en-GB")}`); else sh.getRange("D1").setValue("");
}

// percent formatting (values are 0..100; display with a literal %)
function applyPercentFormats_(sheetName, colIndexList) {
  const sh = SpreadsheetApp.getActive().getSheetByName(sheetName);
  if (!sh || !colIndexList || !colIndexList.length) return;
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return;
  colIndexList.forEach(ci => {
    const rng = sh.getRange(2, ci, lastRow - 1, 1);
    rng.setNumberFormat('0.00"%"');
  });
}

// header-safe percent formatting by column name (0-based index from headerIndexMap_)
function applyPercentFormatsByHeader_(sheetName, headerNames){
  const sh = SpreadsheetApp.getActive().getSheetByName(sheetName);
  if (!sh) return;
  const H = headerIndexMap_(sh); // 0-based
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return;
  headerNames.forEach(h=>{
    const idx = H[h];
    if (idx == null) return;
    sh.getRange(2, idx+1, lastRow-1, 1).setNumberFormat('0.00"%"');
  });
}

// numeric formatting (by index)
function applyNumberFormats_(sheetName, colIndexList) {
  const sh = SpreadsheetApp.getActive().getSheetByName(sheetName);
  if (!sh || !colIndexList || !colIndexList.length) return;
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return;
  colIndexList.forEach(ci => {
    const rng = sh.getRange(2, ci, lastRow - 1, 1);
    rng.setNumberFormat("0.00");
  });
}

// ---- Patch A helper: numeric formatting by header name (safe with strings like "—")
function applyNumberFormatsByHeader_(sheetName, headerNames){
  const sh = SpreadsheetApp.getActive().getSheetByName(sheetName);
  if (!sh) return;
  const H = headerIndexMap_(sh); // 0-based
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return;
  headerNames.forEach(h=>{
    const idx = H[h];
    if (idx == null) return;
    sh.getRange(2, idx+1, lastRow-1, 1).setNumberFormat("0.00");
  });
}

/** ============== Capacity (Per-Day) builder ============== **/
function buildCapacityPerDayFromApi_(tabName, workingDates, capacityByUser, rollup) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(tabName) || ss.insertSheet(tabName);
  sh.clearFormats();
  sh.clearContents();

  const dateFmt = (d)=> Utilities.formatDate(d, Session.getScriptTimeZone(), "EEE dd-MMM");
  const dateHeaders = workingDates.map(dateFmt);
  const headers = ["Name of Resource","Role","Capacity per Day (hrs)"]
                  .concat(dateHeaders)
                  .concat(["Effective Sprint Capacity","Planned Hours","Allocation % (planned/capacity)","Utilization Rate (actual/capacity)","Actual Hours Spent","Remaining Hours","% Progress"]);
  sh.appendRow(headers);

  const unionNames = new Set(Object.keys(capacityByUser).concat(Object.keys(rollup || {})));
  const people = Array.from(unionNames).sort((a,b)=>a.localeCompare(b));
  const rows = [];

  for (const person of people) {
    const cap = capacityByUser[person] || {};
    const capPerDay = (cap.capacityPerDay != null) ? cap.capacityPerDay : null; // may be null
    const personalOff = cap.personalOffSet || new Set();

    const perDay = workingDates.map(d => personalOff.has(fmtDateKey_(d)) ? 0 : (capPerDay ?? 0));

    const r = rollup[person] || { planned: 0, actual: 0, remaining: 0 };
    const planned = round2_(r.planned), actual = round2_(r.actual), remaining = round2_(r.remaining);

    const effCap  = (cap.effectiveCapacity != null)
      ? round2_(cap.effectiveCapacity)
      : round2_(perDay.reduce((a,b)=>a+b,0));

    // % metrics stay 0..100 and are string when capacity unknown to avoid fake 0%
    const allocation = (effCap && effCap > 0) ? round2_(planned/effCap*100) : "—";
    const utilRate   = (effCap && effCap > 0) ? round2_(actual /effCap*100) : "—";
    const progress   = planned ? round2_(actual/planned*100) : 0;

    // Capacity per Day cell shows number or "—"
    const capacityCell = (capPerDay != null) ? round2_(capPerDay) : "—";

    rows.push([person,"", capacityCell].concat(perDay).concat([effCap, planned, allocation, utilRate, actual, remaining, progress]));
  }

  if (rows.length) sh.getRange(2,1,rows.length,headers.length).setValues(rows);
  sh.autoResizeColumns(1, headers.length);
}

/** ============== DAILY SNAPSHOT & UTILIZATION (timestamp-aware) ============== **/

function snapshotRemainingLog_Current() {
  const cfg = { org: ADO_ORG, projectId: ADO_PROJECT_ID, team: ADO_TEAM, pat: ADO_PAT };
  const iteration = getCurrentIteration_(cfg);
  const sprintPath = iteration.path;

  const ids = queryWorkItemIdsForIteration_(cfg, sprintPath, ["Task","Bug"]);
  const fields = [
    "System.Id","System.Title","System.WorkItemType","System.State",
    "System.AssignedTo","Microsoft.VSTS.Scheduling.RemainingWork",
    "Microsoft.VSTS.Common.ClosedDate"
  ];
  const items = fetchWorkItemsBatch_(cfg, ids, fields);

  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName("Remaining_Log") || ss.insertSheet("Remaining_Log");
  const nowTs = new Date();
  const today = todayMidnight_();

  if (sh.getLastRow() === 0) {
    sh.appendRow([
      "Snapshot At","Date","Work Item ID","Title","Assigned To","Remaining (hrs)",
      "Hours Spent Since Last","Scope Added Since Last (hrs)",
      "Type","State","Closed Date"
    ]);
  }

  const H = headerIndexMap_(sh);
  const lastMap = buildLastRemainingMap_(sh, H);

  const rows = [];
  for (const wi of items) {
    const f = wi.fields || {};
    const id = String(wi.id || "");
    const title = f["System.Title"] || "";
    const type = f["System.WorkItemType"] || "";
    const state = f["System.State"] || "";
    const closed = asDateValue_(toDateOrNull_(f["Microsoft.VSTS.Common.ClosedDate"]));
    const assignedTo = extractAssignee_(f["System.AssignedTo"]);
    let remaining = toNumber_(f["Microsoft.VSTS.Scheduling.RemainingWork"]);

    if (closed && closed instanceof Date && ymd_(closed) <= ymd_(today)) remaining = 0;

    const prev = lastMap[id] != null ? lastMap[id] : remaining;
    const delta = round2_((prev || 0) - (remaining || 0));
    const spent = Math.max(0, delta);
    const scopeAdded = Math.max(0, -delta);

    rows.push([
      nowTs, asDateValue_(today), id, title, assignedTo, remaining,
      spent, scopeAdded, type, state, closed
    ]);
  }

  if (rows.length) sh.getRange(sh.getLastRow()+1, 1, rows.length, rows[0].length).setValues(rows);
}

function runDailyUtilizationReport_Current() {
  const cfg = { org: ADO_ORG, projectId: ADO_PROJECT_ID, team: ADO_TEAM, pat: ADO_PAT };
  const iteration = getCurrentIteration_(cfg);
  const sprintName = iteration.name;
  const sprintStart = new Date(iteration.attributes.startDate);
  const sprintEnd   = new Date(iteration.attributes.finishDate);
  const teamDayOffSet = getTeamDaysOff_(cfg, iteration.id);
  const capacityByUser = getCapacityByUser_(cfg, iteration.id, sprintStart, sprintEnd, teamDayOffSet);
  buildDailyUtilizationFromLog_(sprintName, sprintStart, sprintEnd, capacityByUser);
}

function runDailyUtilizationReport_Selected() {
  const cfg = { org: ADO_ORG, projectId: ADO_PROJECT_ID, team: ADO_TEAM, pat: ADO_PAT };
  const ss = SpreadsheetApp.getActive();
  const sel = ss.getSheetByName(SHEET_SELECTOR);
  const idx = ss.getSheetByName(SHEET_INDEX);
  if (!sel || !idx) throw new Error("Please run setupSprintSelector() first.");

  // Stabilized: read picker dynamically
  const Hsel = headerIndexMap_(sel);
  const pickCol = (Hsel["Pick a sprint name"] != null) ? (Hsel["Pick a sprint name"] + 1) : 2;
  const name = (sel.getRange(2, pickCol).getDisplayValue() || "").trim();
  if (!name || name === "No sprints found") throw new Error("No sprint selected.");

  const rows = idx.getRange(2,1,Math.max(0, idx.getLastRow()-1),5).getValues();
  const rec = rows.find(r => String(r[0]).trim() === name);
  if (!rec) throw new Error("Selected sprint not found.");

  const iteration = {
    name: rec[0], id: rec[1], path: rec[2],
    attributes: { startDate: rec[3], finishDate: rec[4] }
  };

  const teamDayOffSet = getTeamDaysOff_(cfg, iteration.id);
  const capacityByUser = getCapacityByUser_(cfg, iteration.id, new Date(rec[3]), new Date(rec[4]), teamDayOffSet);

  buildDailyUtilizationFromLog_(iteration.name, new Date(rec[3]), new Date(rec[4]), capacityByUser);
}

// ✅ Unknown capacity → "—" (N/A) for Available & Utilization
function buildDailyUtilizationFromLog_(sprintName, sprintStart, sprintEnd, capacityByUser) {
  const ss = SpreadsheetApp.getActive();
  const log = ss.getSheetByName("Remaining_Log");
  if (!log || log.getLastRow() < 2) throw new Error("Remaining_Log is empty. Take a snapshot first.");

  const H = headerIndexMap_(log);
  const vals = log.getRange(2,1, log.getLastRow()-1, log.getLastColumn()).getValues();

  const tsIdx = H["Snapshot At"] != null ? H["Snapshot At"] : H["Date"];
  if (tsIdx == null) throw new Error("Remaining_Log missing 'Snapshot At' or 'Date' header.");

  let latestTs = null;
  for (const r of vals) {
    const ts = r[tsIdx];
    if (ts && ts instanceof Date && (!latestTs || ts > latestTs)) latestTs = ts;
  }
  if (!latestTs) throw new Error("No valid snapshot timestamps found.");

  const isSameTs = (d) => (d instanceof Date) && (d.getTime() === latestTs.getTime());
  const todayRows = vals.filter(r => isSameTs(r[tsIdx]));
  const todayKey = fmtDateKey_(latestTs);

  const per = {};
  const touchedByPerson = {};
  const idIdx = H["Work Item ID"], assignedIdx = H["Assigned To"], spentIdx = H["Hours Spent Since Last"],
        scopeIdx = H["Scope Added Since Last (hrs)"], typeIdx = H["Type"], closedIdx = H["Closed Date"];

  for (const r of todayRows) {
    const id = String(r[idIdx]);
    const person = canonicalName_(r[assignedIdx] || "");
    const spent = toNumber_(r[spentIdx]);
    const scopeAdded = toNumber_(r[scopeIdx]);
    const type = (r[typeIdx] || "").toString().toLowerCase();
    const closed = r[closedIdx];

    if (!per[person]) per[person] = { tasks:0, bugs:0, touched:0, spent:0, scope:0, closed:0, bugHours:0 };
    if (!touchedByPerson[person]) touchedByPerson[person] = new Set();
    touchedByPerson[person].add(id);

    per[person].spent += spent;
    per[person].scope += scopeAdded;
    per[person].closed += (closed && closed instanceof Date && fmtDateKey_(closed) === todayKey) ? 1 : 0;
    if (type === "bug") per[person].bugHours += spent;
  }

  const assigned = (() => {
    const counts = {};
    const readTab = (name, typeKey) => {
      const sh = ss.getSheetByName(name);
      if (!sh || sh.getLastRow() < 2) return;
      const vals2 = sh.getRange(2,1, sh.getLastRow()-1, sh.getLastColumn()).getValues();
      for (const v of vals2) {
        const person = canonicalName_(v[3] || "");
        if (!person) continue;
        counts[person] = counts[person] || {tasks:0, bugs:0};
        counts[person][typeKey]++;
      }
    };
    readTab("Tasks", "tasks");
    readTab("Bugs",  "bugs");
    return counts;
  })();

  const out = [];
  const people = new Set([...Object.keys(capacityByUser), ...Object.keys(per), ...Object.keys(assigned)]);
  for (const person of people) {
    const capObj = capacityByUser[person] || {};
    const isWorkingDay = capObj.workingDates ? capObj.workingDates.some(d => fmtDateKey_(d) === todayKey) : false;
    const isPersonalOff = capObj.personalOffSet ? capObj.personalOffSet.has(todayKey) : false;

    // Available hours: number or "—" when unknown or non-working
    const baseAvail = (isWorkingDay && !isPersonalOff) ? (capObj.capacityPerDay ?? null) : 0;
    const available = (baseAvail === null) ? "—" : baseAvail;

    const p = per[person] || { tasks:0, bugs:0, touched:0, spent:0, scope:0, closed:0, bugHours:0 };
    p.touched = (touchedByPerson[person] ? touchedByPerson[person].size : 0);

    const assign = assigned[person] || {tasks:0, bugs:0};

    // Utilization % (0..100) or "—" if unavailable
    const utilization = (typeof available === "number" && available > 0)
      ? round2_(p.spent / available * 100)
      : "—";

    const netBurn = round2_(p.spent - p.scope);
    const bugHourRatio = p.spent ? round2_(p.bugHours / p.spent * 100) : 0;

    out.push([
      latestTs, person, sprintName,
      assign.tasks, assign.bugs,
      p.touched, round2_(p.spent), round2_(p.scope), netBurn, p.closed,
      available, utilization, bugHourRatio
    ]);
  }

  const sh = ss.getSheetByName("Daily Utilization") || ss.insertSheet("Daily Utilization");
  sh.clearFormats(); sh.clearContents();
  const headers = [
    "Snapshot At","Person","Sprint",
    "Total Tasks Assigned","Total Bugs Assigned",
    "Tickets Touched (Latest Snapshot)","Hours Spent (Since Prev Snapshot)","Scope Added (hrs)","Net Burn (hrs)","Tickets Closed (Today)",
    "Available Hours (Today)","Utilization %","Bug Hour Ratio %"
  ];
  sh.appendRow(headers);
  if (out.length) sh.getRange(2,1,out.length,headers.length).setValues(out);
  styleHeaderRow_("Daily Utilization"); wrapHeaderFirstCol_("Daily Utilization");

  // Percent formatting: keep 0..100 literal "%"; skip cells that contain "—"
  applyPercentFormatsByHeader_("Daily Utilization", ["Utilization %","Bug Hour Ratio %"]);
  applyNumberFormats_("Daily Utilization", [6,7,8,10]); // numeric cols (Touched, Spent, Scope, Tickets Closed)
}

/** ============== AUTOMATION: single 2-hour orchestrator ============== **/

function runEvery2h_SnapshotThenUtilization() {
  snapshotRemainingLog_Current();
  Utilities.sleep(4000);
  runDailyUtilizationReport_Current();
}

function installEvery2hAutomation() {
  const targets = new Set([
    "runEvery2h_SnapshotThenUtilization",
    "snapshotRemainingLog_Current",
    "runDailyUtilizationReport_Current"
  ]);
  ScriptApp.getProjectTriggers().forEach(t => {
    if (targets.has(t.getHandlerFunction())) ScriptApp.deleteTrigger(t);
  });
  ScriptApp.newTrigger("runEvery2h_SnapshotThenUtilization").timeBased().everyHours(2).create();
}

function uninstallAutomation() {
  const targets = new Set([
    "runEvery2h_SnapshotThenUtilization",
    "snapshotRemainingLog_Current",
    "runDailyUtilizationReport_Current",
    "runSprintReport_Current",
    "onSprintSelectEdit"
  ]);
  ScriptApp.getProjectTriggers().forEach(t => {
    if (targets.has(t.getHandlerFunction())) ScriptApp.deleteTrigger(t);
  });
}

/** ============== Small utils ============== **/
function enc(s){ return encodeURIComponent(s); }
function escapeQuotes_(s){ return String(s).replace(/'/g, "''"); }
function canonicalName_(s){ if(!s) return ""; return String(s).replace(/\s*<[^>]+>\s*$/, "").trim(); }
function extractAssignee_(assigneeField){
  let raw = "";
  if (!assigneeField) return "";
  if (typeof assigneeField === "string") raw = assigneeField;
  else if (assigneeField.displayName)   raw = assigneeField.displayName;
  else if (assigneeField.uniqueName)    raw = assigneeField.uniqueName;
  return canonicalName_(raw);
}
function toNumber_(v){ const n = Number(v); return isNaN(n) ? 0 : n; }
function pickNumber_(a,b){ const aa = toNumber_(a); return aa ? aa : toNumber_(b); }
function toDateOrNull_(v){ if(!v) return null; const d = new Date(v); return isNaN(d.getTime()) ? null : d; }
function asDateValue_(d){ return d ? new Date(d) : ""; }
function todayMidnight_(){ const t = new Date(); t.setHours(0,0,0,0); return t; }
function ymd_(d){ return d.getFullYear()*10000 + (d.getMonth()+1)*100 + d.getDate(); }
function round2_(n){ return Math.round((n + Number.EPSILON)*100)/100; }
function sortBy_(rows, colIndex){ return rows.sort((a,b)=>{ const x=(a[colIndex]||"").toString().toLowerCase(); const y=(b[colIndex]||"").toString().toLowerCase(); return x<y?-1:x>y?1:0; }); }
function chunk_(arr, size){ const out=[]; for (let i=0;i<arr.length;i+=size) out.push(arr.slice(i, i+size)); return out; }
function fmtDateKey_(d){ const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,"0"); const day=String(d.getDate()).padStart(2,"0"); return `${y}-${m}-${day}`; }
function expandDateRange_(startISO, endISO){
  if (!startISO || !endISO) return [];
  const s = new Date(startISO), e = new Date(endISO);
  s.setHours(0,0,0,0); e.setHours(0,0,0,0);
  const out = [];
  for (let d = new Date(s); d <= e; d = addDays_(d, 1)) out.push(new Date(d));
  return out;
}
function isWeekday_(d){ const day = d.getDay(); return day !== 0 && day !== 6; }
function addDays_(d,n){ const x = new Date(d); x.setDate(x.getDate()+n); return x; }

/** ---------- Remaining Log helpers (header-aware) ---------- **/
function headerIndexMap_(sh) {
  const map = {};
  if (!sh || sh.getLastRow() < 1) return map;
  const lastCol = sh.getLastColumn();
  const headers = sh.getRange(1, 1, 1, lastCol).getValues()[0];
  headers.forEach((h, i) => { map[String(h).trim()] = i; });
  return map;
}
function buildLastRemainingMap_(sh, H) {
  const out = {};
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return out;

  if (!H) H = headerIndexMap_(sh);
  const idIdx = (H["Work Item ID"] != null) ? H["Work Item ID"] : 2;
  const remainingIdx = (H["Remaining (hrs)"] != null) ? H["Remaining (hrs)"] : 6;

  const range = sh.getRange(2, 1, lastRow-1, sh.getLastColumn()).getValues();
  for (let i=0;i<range.length;i++) {
    const row = range[i];
    const id = String(row[idIdx] || "");
    const rem = toNumber_(row[remainingIdx]);
    if (!id) continue;
    out[id] = rem; // last wins
  }
  return out;
}

/** ---------- Debug helper (lists projects) ---------- **/
function listAdoProjects_LogOnly() {
  const url = `https://dev.azure.com/${encodeURIComponent(ADO_ORG)}/_apis/projects?api-version=7.1-preview.4`;
  const resp = UrlFetchApp.fetch(url, {
    method: "GET",
    headers: { "Authorization": "Basic " + Utilities.base64Encode(":" + ADO_PAT) }
  });
  const data = JSON.parse(resp.getContentText());
  Logger.log(JSON.stringify(data.value, null, 2));
}
